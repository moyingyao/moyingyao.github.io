<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AmberWu</title>
  
  <subtitle>越努力，越幸运</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://moyingyao.github.io/"/>
  <updated>2019-03-25T15:32:05.679Z</updated>
  <id>http://moyingyao.github.io/</id>
  
  <author>
    <name>AmberWu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>七月在线-深度学习</title>
    <link href="http://moyingyao.github.io/2019/03/25/20190325%E4%B8%83%E6%9C%88%E5%9C%A8%E7%BA%BF-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    <id>http://moyingyao.github.io/2019/03/25/20190325七月在线-深度学习/</id>
    <published>2019-03-25T02:39:54.000Z</published>
    <updated>2019-03-25T15:32:05.679Z</updated>
    
    <content type="html"><![CDATA[<p>​      </p><a id="more"></a><h3 id="线性与非线性"><a href="#线性与非线性" class="headerlink" title="线性与非线性"></a>线性与非线性</h3><p>线性：随机梯度下降，卷积函数<br>非线性：修正线性单元（Relu）</p><h3 id="Dropout-Boosting-Bagging-Stacking-Mapping"><a href="#Dropout-Boosting-Bagging-Stacking-Mapping" class="headerlink" title="Dropout,Boosting,Bagging,Stacking,Mapping"></a>Dropout,Boosting,Bagging,Stacking,Mapping</h3><h4 id="Bagging和Dropout"><a href="#Bagging和Dropout" class="headerlink" title="Bagging和Dropout"></a>Bagging和Dropout</h4><p>Bagging能实现跟神经网络中Dropout类似的效果。<br>Dropout是将许多单独训练的子网络集成起来，某些权值是共享的。<br>Bagging是将许多单独训练的学习机集成起来；<br>Dropout和Bagging这两种方法都是把若干个分类器整合为一个分类器的方法，只是整合的方式不一样，最终得到不一样的效果，将不同的分类算法套入到此类算法框架中一定程度上会提高了原单一分类器的分类效果，但是也增大了计算量。</p><h4 id="Bagging和Boosting的区别："><a href="#Bagging和Boosting的区别：" class="headerlink" title="Bagging和Boosting的区别："></a>Bagging和Boosting的区别：</h4><p>Boosting并不是单独训练的，而是按照有一定的顺序训练的，具有相互依赖关系。</p><p>1）样本选择上：<br>Bagging：训练集是在原始集中有放回选取的，从原始集中选出的各轮训练集之间是独立的。<br>Boosting：每一轮的训练集不变，只是训练集中每个样例在分类器中的权重发生变化。而权值是根据上一轮的分类结果进行调整。<br>2）样例权重：<br>Bagging：使用均匀取样，每个样例的权重相等。<br>Boosting：根据错误率不断调整样例的权值，错误率越大则权重越大。<br>3）预测函数：<br>Bagging：所有预测函数的权重相等。<br>Boosting：每个弱分类器都有相应的权重，对于分类误差小的分类器会有更大的权重。<br>4）并行计算：<br>Bagging：各个预测函数可以并行生成<br>Boosting：各个预测函数只能顺序生成，因为后一个模型参数需要前一轮模型的结果</p><p>Stacking是通过两层学习机完成的学习。</p><h3 id="处理过拟合的方法"><a href="#处理过拟合的方法" class="headerlink" title="处理过拟合的方法"></a>处理过拟合的方法</h3><p>Dropout；</p><h3 id="调整超参数来最小化代价函数（cost-functon）的技术："><a href="#调整超参数来最小化代价函数（cost-functon）的技术：" class="headerlink" title="调整超参数来最小化代价函数（cost functon）的技术："></a>调整超参数来最小化代价函数（cost functon）的技术：</h3><p>网格搜索，随机搜索，贝叶斯（bayesian）优化，居于梯度的优化。</p><h3 id="批规范化（Batch-Normalization）的好处："><a href="#批规范化（Batch-Normalization）的好处：" class="headerlink" title="批规范化（Batch Normalization）的好处："></a>批规范化（Batch Normalization）的好处：</h3><p>增加反向传播速度，避免梯度消失；<br>加速网络收敛；<br>减轻参数初始化的影响。<br>批规范化（Batch Normalization）<strong>不能处理过拟合</strong>，因为同一个数据在不同批中被归一化后的值会有差别，相当于做了数据增强（data augmentation）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​      &lt;/p&gt;
    
    </summary>
    
      <category term="七月在线" scheme="http://moyingyao.github.io/categories/%E4%B8%83%E6%9C%88%E5%9C%A8%E7%BA%BF/"/>
    
    
      <category term="DL" scheme="http://moyingyao.github.io/tags/DL/"/>
    
      <category term="七月在线" scheme="http://moyingyao.github.io/tags/%E4%B8%83%E6%9C%88%E5%9C%A8%E7%BA%BF/"/>
    
      <category term="笔试题" scheme="http://moyingyao.github.io/tags/%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>集群上Docker的简单使用</title>
    <link href="http://moyingyao.github.io/2018/07/27/20180727Docker%E9%9B%86%E7%BE%A4%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/"/>
    <id>http://moyingyao.github.io/2018/07/27/20180727Docker集群使用文档/</id>
    <published>2018-07-27T10:27:24.000Z</published>
    <updated>2019-03-15T04:46:58.872Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。<br>由于深度学习众多框架如果同时使用会互相影响，在集群上使用docker可以很好地解决这种情况。<br><a id="more"></a></p></blockquote><h3 id="用户管理-管理员权限"><a href="#用户管理-管理员权限" class="headerlink" title="用户管理 (管理员权限)"></a>用户管理<font color="#FF0000"> (管理员权限)</font></h3><h4 id="添加docker用户组"><a href="#添加docker用户组" class="headerlink" title="添加docker用户组:"></a>添加docker用户组:</h4><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd -g <span class="number">344</span> docker</span><br></pre></td></tr></table></figure><h4 id="添加用户到用户组："><a href="#添加用户到用户组：" class="headerlink" title="添加用户到用户组："></a>添加用户到用户组：</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -<span class="selector-tag">a</span> -G 用户组 用户</span><br></pre></td></tr></table></figure><blockquote><p>即给用户docker的使用权限，放开权限后，需要重启docker服务。</p></blockquote><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">service docker restart</span></span><br></pre></td></tr></table></figure><h4 id="从用户组中删除用户"><a href="#从用户组中删除用户" class="headerlink" title="从用户组中删除用户"></a>从用户组中删除用户</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpasswd -d 用户 用户组</span><br></pre></td></tr></table></figure><h3 id="镜像的基本操作"><a href="#镜像的基本操作" class="headerlink" title="镜像的基本操作"></a>镜像的基本操作</h3><h4 id="列出本地镜像"><a href="#列出本地镜像" class="headerlink" title="列出本地镜像"></a>列出本地镜像</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p><img src="/2018/07/27/20180727Docker集群使用文档/1.png" alt="示例图片"></p><blockquote><p>各个选项说明:</p><ul><li>REPOSITORY：表示镜像的仓库源（不唯一）</li><li>TAG：镜像的标签(不唯一，可以自己设定)</li><li>IMAGE ID：镜像ID（唯一）</li><li>CREATED：镜像创建时间</li><li>SIZE：镜像大小<br>同一个镜像ID可以有多个仓库源和标签，如图中红框所示。</li></ul></blockquote><h4 id="查找镜像"><a href="#查找镜像" class="headerlink" title="查找镜像"></a>查找镜像</h4><blockquote><p>我们可以从Docker Hub网站来搜索镜像，Docker Hub网址为：<a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a><br>我们也可以使用docker search命令来搜索镜像。比如我们需要一个httpd的镜像来作为我们的web服务。我们可以通过docker search命令搜索httpd来寻找适合我们的镜像。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search httpd</span><br></pre></td></tr></table></figure><p><img src="/2018/07/27/20180727Docker集群使用文档/2.png" alt="示例图片"></p><blockquote><ul><li>NAME:镜像仓库源的名称</li><li>DESCRIPTION:镜像的描述</li><li>OFFICIAL:是否docker官方发布</li></ul></blockquote><h4 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h4><blockquote><p>当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用docker pull命令来下载它。<br>此处以ubuntu:15.10为例,其中15.10为标签，若不写，会默认下载最新的镜像，标签为latest。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 镜像名(:标签)</span><br></pre></td></tr></table></figure><h4 id="设置镜像标签"><a href="#设置镜像标签" class="headerlink" title="设置镜像标签"></a>设置镜像标签</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag 原始镜像名 新镜像名:标签</span><br></pre></td></tr></table></figure><p><img src="/2018/07/27/20180727Docker集群使用文档/3.png" alt="示例图片"></p><blockquote><p>发现镜像ID为00a10af6cf18的镜像多了一个新的标签 liufan。</p></blockquote><h4 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h4><blockquote><p>当我们删除某一镜像时，会先尝试删除所有指向该镜像的标签，然后删除该镜像本身。</p></blockquote><p><strong>1.若一个镜像有多个标签，我们只想删除已经没用的标签</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi 仓库源<span class="comment">(liufan)</span>: 镜像标签<span class="comment">(lf)</span></span><br></pre></td></tr></table></figure><blockquote><p>删除前后</p></blockquote><p><img src="/2018/07/27/20180727Docker集群使用文档/4.png" alt="示例图片"><br><img src="/2018/07/27/20180727Docker集群使用文档/5.png" alt="示例图片"></p><blockquote><p>我们发现liufan:lf已经被删除</p></blockquote><p><strong>2.彻底删除镜像</strong></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi –f 镜像ID（以<span class="number">8</span><span class="keyword">c</span><span class="number">811</span>b<span class="number">4</span>aec<span class="number">35</span>为例）（不建议-f强制删除）</span><br></pre></td></tr></table></figure><p><img src="/2018/07/27/20180727Docker集群使用文档/6.png" alt="示例图片"></p><blockquote><p>我们发现8c811b4aec35这个镜像已经被彻底删除（包含所有指向这个镜像的标签）</p></blockquote><p><strong>3.若想删除的镜像有基于它创建的容器存在时，镜像文件是默认无法删除的。</strong><font color="#FF0000">（容器会在下面章节有所讲解）</font></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name liufan ubuntu/numpy /bin/bash</span><br></pre></td></tr></table></figure><p><img src="/2018/07/27/20180727Docker集群使用文档/7.png" alt="示例图片"></p><blockquote><p>我们基于ubuntu/numpy这个镜像创建了一个名为liufan的容器。下面我们退出容器，尝试删除这个镜像，docker会提示有容器在运行，无法删除：</p></blockquote><p><img src="/2018/07/27/20180727Docker集群使用文档/8.png" alt="示例图片"></p><blockquote><p>若想强制删除，可使用2中的 docker rmi –f 镜像ID，但不建议这样做，因为有容器依赖这个镜像，强制删除会有遗留问题（强制删除的镜像换了新的ID继续存在系统中）</p></blockquote><h4 id="导入导出镜像"><a href="#导入导出镜像" class="headerlink" title="导入导出镜像"></a>导入导出镜像</h4><h5 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save 镜像(busybox) &gt; 存储位置(/home/lf/aa.tar)</span><br></pre></td></tr></table></figure><p><img src="/2018/07/27/20180727Docker集群使用文档/9.png" alt="示例图片"></p><blockquote><p>已经在对应目录生成压缩文件<br>先把本地的busybox镜像删除，然后尝试导入刚刚导出的压缩镜像</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi busybox &amp;&amp; docker images</span><br></pre></td></tr></table></figure><p><img src="/2018/07/27/20180727Docker集群使用文档/10.png" alt="示例图片"></p><h5 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load &lt; (镜像存储位置)/home/lf/aa.tar</span><br></pre></td></tr></table></figure><p><img src="/2018/07/27/20180727Docker集群使用文档/11.png" alt="示例图片"></p><blockquote><p>我们发现busybox镜像已经成功导入。</p></blockquote><blockquote><p><strong>注意</strong>：当已有的镜像不能满足我们的需求时，我们需要自己制作镜像，主要通过下面2种方式：<br>1）    通过Dockerfile文件制作镜像（较难）<br>2）    基于一个原始镜像创建一个容器，在容器里面进行一些操作（安装一些框架或者软件包），然后退出容器，利用commit命令提交生成新的镜像 （简单）</p></blockquote><h3 id="容器基本操作"><a href="#容器基本操作" class="headerlink" title="容器基本操作"></a>容器基本操作</h3><blockquote><p>容器是镜像的一个运行实例，它是基于镜像创建的。</p></blockquote><h4 id="新建容器"><a href="#新建容器" class="headerlink" title="新建容器"></a>新建容器</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker create -it --name lf tensorflow</span><br><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><p><img src="/2018/07/27/20180727Docker集群使用文档/12.png" alt="示例图片"></p><blockquote><p>可以看见我们成功创建了一个名为lf，基于tensorflow镜像的容器。<br>使用docker create 命令新建的容器一开始是处于停止状态的，需要用如下命令来启动并进入它。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker start lf</span><br><span class="line">docker attach lf</span><br></pre></td></tr></table></figure><p><img src="/2018/07/27/20180727Docker集群使用文档/13.png" alt="示例图片"></p><h4 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h4><blockquote><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it  --name liufan ubuntu/numpy /bin/bash</span><br></pre></td></tr></table></figure><blockquote><p>上述命令等价于先执行docker create,再执行docker start和docker attach命令。</p></blockquote><p><img src="/2018/07/27/20180727Docker集群使用文档/14.png" alt="示例图片"></p><blockquote><p>上面我们以交互模式创建了一个基于ubuntu/numpy镜像，名为liufan的容器。<br>命令中：</p><ul><li>-i：表示让容器的标准输入保持打开，</li><li>-t：让docker分配一个伪终端并绑定到容器的标准输入上，</li><li>/bin/bash：不是必要选项，只是在表明创建容器的时候并运行了bash应用，方便我们进入容器内部，不写也可以，不过那就要用其他命令进入容器了。（docker中必须要保持一个进程的运行，要不然整个容器就会退出）</li></ul></blockquote><blockquote><p>我们可以按Ctrl+d或输入exit命令来退出容器。退出后该容器就会处于终止状态（stopped），可通过3.1中的start和attach重新进入容器。</p></blockquote><h4 id="查看终止删除容器"><a href="#查看终止删除容器" class="headerlink" title="查看终止删除容器"></a>查看终止删除容器</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps // 查看所有正在运行容器</span><br></pre></td></tr></table></figure><p><img src="/2018/07/27/20180727Docker集群使用文档/15.png" alt="示例图片"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a // 查看所有容器</span><br></pre></td></tr></table></figure><p><img src="/2018/07/27/20180727Docker集群使用文档/16.png" alt="示例图片"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a -q // 查看所有容器ID</span><br></pre></td></tr></table></figure><p><img src="/2018/07/27/20180727Docker集群使用文档/17.png" alt="示例图片"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop containerId // 停止容器运行，containerId 是容器的ID或者名字，一个或多个</span><br></pre></td></tr></table></figure><p><img src="/2018/07/27/20180727Docker集群使用文档/18.png" alt="示例图片"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm containerId // 删除容器，containerId 是容器的ID或者名字，一个或多个</span><br></pre></td></tr></table></figure><p><img src="/2018/07/27/20180727Docker集群使用文档/19.png" alt="示例图片"></p><blockquote><p>可以看到lf、wh这两个容器已经被删除</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop $(docker ps -a -q) //  stop停止所有容器</span><br></pre></td></tr></table></figure><p><img src="/2018/07/27/20180727Docker集群使用文档/20.png" alt="示例图片"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker  rm $(docker ps -a -q) //   删除所有容器</span><br></pre></td></tr></table></figure><p><img src="/2018/07/27/20180727Docker集群使用文档/21.png" alt="示例图片"></p><blockquote><p><strong>注意：</strong>删除容器时必须保证容器是终止态（stopped），若不是先进行docker stop操作再进行docker rm操作，可以-f强制删除但不建议。</p></blockquote><h4 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h4><p><strong>1.attach命令</strong><br><img src="/2018/07/27/20180727Docker集群使用文档/22.png" alt="示例图片"></p><blockquote><p>使用attach命令有时候并不方便。当多个窗口同时attach到同一个容器的时候，所有的窗口都会同步显示。当某个窗口因命令阻塞时，其他窗口就无法执行操作了。</p></blockquote><p><strong>2.exec命令</strong></p><blockquote><p>docker自1.3版本起，提供了一个更加方便的工具exec，可以直接在容器内部运行命令，例如进入到刚创建的容器中，并启动一个bash</p></blockquote><p><img src="/2018/07/27/20180727Docker集群使用文档/23.png" alt="示例图片"></p><h4 id="导入和导出容器"><a href="#导入和导出容器" class="headerlink" title="导入和导出容器"></a>导入和导出容器</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name liufan ubuntu/numpy /bin/bash</span><br></pre></td></tr></table></figure><p><img src="/2018/07/27/20180727Docker集群使用文档/24.png" alt="示例图片"></p><blockquote><p>我们基于ubuntu/numpy镜像创建了一个名为liufan的容器，下面将它<strong>导出</strong>：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export 容器名(liufan) &gt; 存储地址(/home/lf/aa.tar)</span><br></pre></td></tr></table></figure><p><img src="/2018/07/27/20180727Docker集群使用文档/25.png" alt="示例图片"><br>我们将liufan这个容器导出本地并压缩命名为aa.tar文件。</p><blockquote><p><strong>导入：</strong><br>先将liufan容器删除在尝试导入</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stop liufan &amp;&amp;docker rm liufan &amp;&amp;docker ps -a</span><br><span class="line">docker <span class="keyword">import</span> /home/lf/aa.tar test/ubuntu:lf</span><br></pre></td></tr></table></figure><p><img src="/2018/07/27/20180727Docker集群使用文档/26.png" alt="示例图片"><br><img src="/2018/07/27/20180727Docker集群使用文档/27.png" alt="示例图片"></p><blockquote><p>我们可以看到刚刚的容器压缩文件已经成功导入，命名为test/ubuntu:lf镜像。<br>前面第一章中的1.6节中，我们介绍过用docker load命令来导入一个镜像文件，其实这边也可以用docker import命令来导入一个镜像到本地镜像库。</p></blockquote><p><strong>两者的区别是：</strong></p><blockquote><p>docker import：丢弃了所有的历史记录和元数据信息，仅保存容器当时的快照状态。在导入的时候可以重新制定标签等元数据信息。<br>docker load：将保存完整记录，体积较大。</p></blockquote><h3 id="代码实例（以Tensorflow为例）"><a href="#代码实例（以Tensorflow为例）" class="headerlink" title="代码实例（以Tensorflow为例）"></a>代码实例（以Tensorflow为例）</h3><blockquote><p>上面两章我介绍了镜像和容器的关系和它们的一些基本操作，接下来我将介绍如何在创建的容器里面运行我们的代码。<br>集群上有Tensorflow、Pytorch、Caffe、MXNet等深度学习框架的镜像，此处我已Tensorflow为例，介绍如何在容器里运行我们的代码。</p></blockquote><h4 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name liufan bluesliuf/tensorflow /bin/bash</span><br></pre></td></tr></table></figure><p><img src="/2018/07/27/20180727Docker集群使用文档/28.png" alt="示例图片"></p><blockquote><p>我们基于bluesliuf/tensorflow这个镜像创建了一个名为liufan的镜像，进入容器ls查看目录列表，发现此时的容器就类似一个Linux环境，默认的用户权限为root权限。</p></blockquote><font color="#FF0000">问题：</font>我们的代码和数据集都在本地机器上，如何放到容器内部呢？直接复制困难并且耗时，如果我们的数据集过大。<br>Docker提供了一种方法：<font color="#FF0000">挂载</font>。将我们的本地目录挂载到容器内部，实现本机目录文件和容器目录文件共享。<br><br><strong>挂载本地目录到容器</strong><br><strong>注意</strong>：不可先创建容器，再挂载本地目录，两者必须同时进行，于是我们重新创建容器并挂载本地目录。<br>我的代码和数据集都放在本机/home/lf/lf/catdogs目下，下面将它挂载到容器内。<br><img src="/2018/07/27/20180727Docker集群使用文档/29.png" alt="示例图片"><br>创建容器有2种方式<br>1.<strong>未调用GPU</strong>，在终端输入命令：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v /home/lf/lf/catdogs:/var/catdogs --name liufan bluesliuf/tensorflow /bin/bash</span><br></pre></td></tr></table></figure><br><br>2.<strong>调用GPU</strong>，在终端输入命令：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v /home/lf/lf/catdogs:/var/catdogs -v /usr/local/docker-inspur/nvidia-volumes/volume:/usr/local/nvidia:ro --volume-driver=nvidia-docker --device=/dev/nvidiactl --device=/dev/nvidia-uvm --device=/dev/nvidia-uvm-tools --device=/dev/nvidia0 --device=/dev/nvidia1 --device=/dev/nvidia2 --device=/dev/nvidia3 --device=/dev/nvidia4 --device=/dev/nvidia5 --name liufan bluesliuf/tensorflow /bin/bash</span><br></pre></td></tr></table></figure><br><br><strong>-v:</strong>挂载的命令参数<br><strong>冒号前：</strong>本地目录的绝对路径<br><strong>冒号后：</strong>容器挂载本地目录的绝对路径<br><strong>调用GPU比不调用GPU多出的部分：</strong>表示容器需要使用GPU 时将显卡驱动映射到容器中，默认参数不用修改，如果不使用GPU，可以不加此部分<br><strong>name: </strong>创建的容器名<br><strong>bluesliuf/tensorflow:</strong>基于的镜像<br><br><font size="4">不调用GPU（本机）：</font><br><img src="/2018/07/27/20180727Docker集群使用文档/30.png" alt="示例图片"><br><font size="4">调用GPU（集群）：</font><br><img src="/2018/07/27/20180727Docker集群使用文档/31.png" alt="示例图片"><br>可以看见我们已经成功将本地目录挂载到了我们指定的容器内部位置。<br><font size="4">运行代码（本机）：</font><br><font color="#FF0000">注:</font>本地代码里面通常会有数据集的读取路径，一些生成日志文件的存储路径，我们要对它进行修改，换为容器内读取和存储路径。<br><img src="/2018/07/27/20180727Docker集群使用文档/32.png" alt="示例图片"><br>再去容器内部看，本地的修改已经同步到容器内了。<br><img src="/2018/07/27/20180727Docker集群使用文档/33.png" alt="示例图片"><br>在本地修改文件和容器内修改文件都行，一处修改两者都会同步修改。但建议在本地修改，因为本地修改起来方便，容器内一般用vim编辑器，较为不便。<br>在终端输入命令：<font color="#FF0000">python 代码文件名（此处我是training.py）</font><p><font size="4">不调用GPU（本机）：</font><br><img src="/2018/07/27/20180727Docker集群使用文档/34.png" alt="示例图片"><br><img src="/2018/07/27/20180727Docker集群使用文档/35.png" alt="示例图片"></p><p>可以看见代码已经成功运行，并且相应的日志文件也存储到本地目录（容器目录当然也有，两者是同步共享的）<br>此外，docker还提供了类似screen，可以让容器在后台运行的功能，退出时如果想继续运行：按顺序按<font color="#FF0000">【ctrl+p】【ctrl+q】</font>，下次再使用docker attach 或者docker exec进入容器，可以看见我们的程序还在继续运行。例如：<br><img src="/2018/07/27/20180727Docker集群使用文档/36.png" alt="示例图片"></p><p><font size="4">调用GPU：</font><br><img src="/2018/07/27/20180727Docker集群使用文档/37.png" alt="示例图片"><br>在后台运行和上面一样，也是利用<font color="#FF0000">【ctrl+p】【ctrl+q】</font>。</p><h4 id="数据卷挂载"><a href="#数据卷挂载" class="headerlink" title="数据卷挂载"></a>数据卷挂载</h4><p>Docker针对挂载目录还提供了一种高级的用法。叫数据卷。</p><p><font color="#FF0000">数据卷：“其实就是一个正常的容器，专门用来提供数据卷供其它容器挂载的”。</font>感觉它就像是由一个容器定义的一个数据挂载信息。其他的容器启动可以直接挂载数据卷容器中定义的挂载信息。示例如下：<br>1.创建一个普通的容器，名为wuhao，并将本地的文件目录挂载到了容器，接下来把这个容器当做一个数据卷。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v /home/lf/lf/catdogs:/var/catdogs --name wuhao bluesliuf/tensorflow /bin/bash</span><br></pre></td></tr></table></figure></p><p>2.再创建一个新的容器，来使用这个数据卷。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --volumes-<span class="keyword">from</span> wuhao --name lf bluesliuf/tensorflow /bin/bash</span><br></pre></td></tr></table></figure></p><p><font color="#FF0000">–volumes-from</font>用来指定要从哪个数据卷来挂载数据。<br><img src="/2018/07/27/20180727Docker集群使用文档/38.png" alt="示例图片"><br>我们可以发现通过wuhao这个容器（数据卷），我们成功的将本地目录也挂载到了lf这个容器内。</p><p><font color="#FF0000"><strong>通过数据卷挂载目录更具有优势。</strong></font><br>1）    我们只需先创建一个容器并挂载本地目录，将其看成数据卷，当我们其他容器也需要挂载同样目录的时候，我们只需要利用–volumes-from就可以实现。<br>2）    当我们需要挂载的本地目录发生改变时，我们只需要修改作为数据卷那个容器挂载的本地目录即可<font color="#FF0000">（类似一个全局变量）</font>，而无须一个个修改其他容器的本地挂载目录。</p><p>挂载成功后。运行代码步骤与上面一样。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。&lt;br&gt;由于深度学习众多框架如果同时使用会互相影响，在集群上使用docker可以很好地解决这种情况。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://moyingyao.github.io/categories/Docker/"/>
    
    
      <category term="集群" scheme="http://moyingyao.github.io/tags/%E9%9B%86%E7%BE%A4/"/>
    
      <category term="Docker" scheme="http://moyingyao.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>深度学习的常见模型-GAN</title>
    <link href="http://moyingyao.github.io/2018/07/05/20180705%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%B8%B8%E8%A7%81%E6%A8%A1%E5%9E%8B-GAN/"/>
    <id>http://moyingyao.github.io/2018/07/05/20180705深度学习的常见模型-GAN/</id>
    <published>2018-07-05T14:27:24.000Z</published>
    <updated>2019-03-14T11:39:02.051Z</updated>
    
    <content type="html"><![CDATA[<h3 id="GAN的来源"><a href="#GAN的来源" class="headerlink" title="GAN的来源"></a>GAN的来源</h3><blockquote><p>2014年Goodfellow提出Generative Adversarial Nets即生成式对抗网络，它要解决的问题是如何从训练样本中学习出新样本，训练样本是图片就生成新图片，训练样本是文章就输出新文章等等。</p></blockquote><a id="more"></a><blockquote><p>GANs简单的想法就是用两个模型，<font color="#FF0000"> 一个生成模型，一个判别模型。</font>判别模型用于判断一个给定的图片是不是真实的图片（从数据集里获取的图片），生成模型的任务是去创造一个看起来像真的图片一样的图片，有点拗口，就是说模型自己去产生一个图片，可以和你想要的图片很像。而在开始的时候这两个模型都是没有经过训练的，<font color="#FF0000">这两个模型一起对抗训练，生成模型产生一张图片去欺骗判别模型，然后判别模型去判断这张图片是真是假</font>，最终在这两个模型训练的过程中，两个模型的能力越来越强，最终达到稳态。</p></blockquote><h3 id="GAN的基本组成"><a href="#GAN的基本组成" class="headerlink" title="GAN的基本组成"></a>GAN的基本组成</h3><blockquote><p>GAN 模型中的两位博弈方分别由<font color="#FF0000">生成式模型</font>（Generative Model）和<font color="#FF0000">判别式模型</font>（Discriminative Model）充当。</p></blockquote><blockquote><blockquote><p>生成模型： G 捕捉样本数据的分布，用服从某一分布（均匀分布，高斯分布等）的噪声 z 生成一个类似真实训练数据的样本，追求效果是越像真实样本越好；</p></blockquote></blockquote><blockquote><blockquote><p>判别模型: D 是一个二分类器，估计一个样本来自于训练数据（而非生成数据）的概率，如果样本来自于真实的训练数据，D 输出大概率，否则，D 输出小概率。</p></blockquote></blockquote><blockquote><blockquote><p>可以做如下类比：生成网络 G 好比假币制造团伙，专门制造假币，判别网络 D 好比警察，专门检测使用的货币是真币还是假币，G 的目标是想方设法生成和真币一样的货币，使得 D 判别不出来，D 的目标是想方设法检测出来 G 生成的假币。</p></blockquote></blockquote><p><img src="/2018/07/05/20180705深度学习的常见模型-GAN/1.png" alt="示例图片"></p><blockquote><p>上图是GAN网络的流程图，我们用1代表真实数据，0来代表生成的假数据。对于判别器D来说，对于真实数据，它要尽可能让判别器输出值为1；而对于生成器G，根据随机噪音向量z生成假数据也输入判别器D，使得判别器输出假数据的值为1是生成器的目标，而对于这些假数据，判别器要尽可能输出0。<br>GAN的训练过程可以看成一个博弈的过程，也可以看成2个人在玩一个极大极小值游戏，可以用如下公式表示：</p></blockquote><p><img src="/2018/07/05/20180705深度学习的常见模型-GAN/111.png" alt="示例图片"></p><blockquote><p>其本质上是两个优化问题，把拆解就如同下面两个公式，上面是优化D的，下面是优化G的。</p></blockquote><p><img src="/2018/07/05/20180705深度学习的常见模型-GAN/222.png" alt="示例图片"></p><blockquote><p>当优化D时，生成器确定,我们要让判别器尽可能输出高的值，所以要最大化公式(2)的值；当优化G的时候，判别器确定，我们要使判别器判断错误，尽可能使D(G(z))的值更大，所以要最小化公式(3)的值。</p></blockquote><h3 id="GAN的训练过程"><a href="#GAN的训练过程" class="headerlink" title="GAN的训练过程"></a>GAN的训练过程</h3><blockquote><p>下图为GAN的训练过程。<br>生成式对抗网络主要由生成器G和判别器D组成，训练过程如下所述：</p><ul><li>输入噪声（隐藏变量）Z</li><li>通过生成器G得到x_fake=G(z)</li><li>从真实数据集中获取一部分真实数据x_real</li><li>将两者混合x=x_fake+x_real</li><li>将数据喂入判别部分D，给定标签x_fake=0,x_real=1,这一过程就是简单的二分类</li><li>按照分类结果，回传loss</li></ul></blockquote><blockquote><p>在整个过程中，D要尽可能的使D(G(z))=0,D(x_real)=1（火眼金睛，不错杀也不漏杀）。而G则要使得D(G(z))=1(即让生成的图片以假乱真)</p></blockquote><p><img src="/2018/07/05/20180705深度学习的常见模型-GAN/2.png" alt="示例图片"></p><p>GAN的算法流程和动态求解过程如下图所示：</p><blockquote><p><img src="/2018/07/05/20180705深度学习的常见模型-GAN/3.png" alt="示例图片"><br><img src="/2018/07/05/20180705深度学习的常见模型-GAN/4.png" alt="示例图片"><br>一开始我们确定G，最大化D，让点沿着D变大的方向移动(红色箭头)，然后我们确定D，最小化G，让点沿着G变小的方向移动(蓝色箭头)。循环上述若干步后，达到期望的鞍点(理想最优解)。</p></blockquote><h3 id="GAN的网络结构"><a href="#GAN的网络结构" class="headerlink" title="GAN的网络结构"></a>GAN的网络结构</h3><h4 id="判别器-卷积"><a href="#判别器-卷积" class="headerlink" title="判别器(卷积)"></a><font color="#FF0000">判别器(卷积)</font></h4><blockquote><p>卷积层大家应该都很熟悉了,为了方便说明，定义如下：</p><ul><li>二维的离散卷积（N=2）</li><li>方形的特征输入（i<sub>1</sub>=i<sub>2</sub>=i）</li><li>方形的卷积核尺寸（k<sub>1</sub>=k<sub>2</sub>=k ）</li><li>每个维度相同的步长（s<sub>1</sub>=s<sub>2</sub>=s）</li><li>每个维度相同的padding (p<sub>1</sub>=p<sub>2</sub>=p)</li></ul></blockquote><blockquote><p>下图(左)表示参数为 (i=5,k=3,s=2,p=1)的卷积计算过程，从计算结果可以看出输出特征的尺寸为 (o<sub>1</sub>=o<sub>2</sub>=o=3)；下图(右)表示参为 (i=6,k=3,s=2,p=1)的卷积计算过程，从计算结果可以看出输出特征的尺寸为 (o<sub>1</sub>=o<sub>2</sub>=o=3)。</p></blockquote><p><img src="/2018/07/05/20180705深度学习的常见模型-GAN/5.png" alt="示例图片"></p><blockquote><p>从上述2个例子我们可以总结出卷积层输入特征和输出特征尺寸和卷积核参数的关系为：</p></blockquote><p><img src="/2018/07/05/20180705深度学习的常见模型-GAN/333.png" alt="示例图片"></p><h4 id="生成器-反卷积"><a href="#生成器-反卷积" class="headerlink" title="生成器(反卷积)"></a><font color="#FF0000">生成器(反卷积)</font></h4><blockquote><p>在介绍反卷积之前，我们先来看一下卷积运算和矩阵运算之间的关系。例有如下运算(i=4,k=3,s=1,p=0)，输出为o=2。对于上述卷积运算，我们把上图所示的3x3卷积核展开成一个如下图所示的[4.16]的稀疏矩阵C，其中非0元素W<sub>i,j</sub>表示卷积核的第i行和第j列。</p></blockquote><p><img src="/2018/07/05/20180705深度学习的常见模型-GAN/6.png" alt="示例图片"></p><blockquote><p>我们再把4x4的输入特征展开成[16,1]的矩阵X，那么Y=CX则是一个[4,1]的输出特征矩阵，把它重新排列成2x2的输出特征就得到最终的结果，从上述分析可以看出卷积层的计算其实是可以转化成矩阵相乘的。值得注意的是，在一些深度学习网络的开源框架中，并不是通过这种转换方法来计算卷积的，因为这个转换会存在很多无用的0乘操作，caffe中具体实现卷积计算的方法可以参考impleming convolution as a matrix multiplication。</p></blockquote><blockquote><p>通过上述的分析，我们已经知道卷积层的前向操作可以表示为和矩阵C相乘，那么<font color="#FF0000">我们很容易得到卷积层的反向传播就是和C的转置相乘。</font></p></blockquote><p><strong>反卷积和卷积的关系如下</strong></p><blockquote><p>反卷积又称transposed（转置） convolution，我们可以看出其实卷积层的前向传播过程就是反卷积层的反向传播过程，卷积层的反向传播过程就是反卷积层的前向传播过程。因为卷积层的前向反向计算分别为乘C和C<sup>T</sup>,而反卷积层的前向反向计算分别为乘C<sup>T</sup>和(C<sup>T</sup>)<sup>T</sup>,所以他们的前向传播和反向传播刚好交换过来。<br>同样为了说明，定义反卷积操作参数如下：</p><ul><li>二维的离散卷积（N=2）</li><li>方形的特征输入（i<sub>1</sub><sup>‘</sup>=i<sub>2</sub><sup>‘</sup>=i<sup>‘</sup>）</li><li>方形的卷积核尺寸（k<sub>1</sub><sup>‘</sup>=k<sub>2</sub><sup>‘</sup>=k<sup>‘</sup>）</li><li>每个维度相同的步长（s<sub>1</sub><sup>‘</sup>=s<sub>2</sub><sup>‘</sup>=s<sup>‘</sup>）</li><li>每个维度相同的padding (p<sub>1</sub><sup>‘</sup>=p<sub>2</sub><sup>‘</sup>=p<sup>‘</sup>)<br><img src="/2018/07/05/20180705深度学习的常见模型-GAN/7.png" alt="示例图片"><br>上图表示的是参数为( i′=2,k′=3,s′=1,p′=2)的反卷积操作，其对应的卷积操作参数为 (i=4,k=3,s=1,p=0)。我们可以发现对应的卷积和非卷积操作其 (k=k′,s=s′)，但是反卷积却多了p′=2。通过对比我们可以发现卷积层中左上角的输入只对左上角的输出有贡献，所以反卷积层会出现 p′=k−p−1=2。通过示意图，我们可以发现，反卷积层的输入输出在 s=s′=1的情况下关系为： <strong>o′=i′-k′+2p′+1=i′+(k-1)-2p</strong></li></ul></blockquote><p><strong>GAN的优点</strong></p><blockquote><ul><li>GAN是一种生成式模型，相比较其他生成模型（玻尔兹曼机和GSNs）只用到了反向传播 </li><li>相比其他所有模型, GAN可以产生更加清晰，真实的样本</li><li>GAN采用的是一种无监督的学习方式训练，可以被广泛用在无监督学习和半监督学习领域</li></ul></blockquote><p><strong>GAN的缺点</strong></p><blockquote><ul><li>训练GAN需要达到纳什均衡,有时候可以用梯度下降法做到,有时候做不到.我们还没有找到很好的达到纳什均衡的方法,所以训练GAN相比VAE或者PixelRNN是不稳定的</li><li>GAN不适合处理离散形式的数据，比如文本</li><li>GAN存在训练不稳定、梯度消失、模式崩溃的问题</li></ul></blockquote><h3 id="实例DCGAN网络"><a href="#实例DCGAN网络" class="headerlink" title="实例DCGAN网络"></a>实例DCGAN网络</h3><p><strong>网络结构 (判别器)</strong><br> <img src="/2018/07/05/20180705深度学习的常见模型-GAN/8.png" alt="示例图片"> </p><p><strong>网络结构 (生成器)</strong><br> <img src="/2018/07/05/20180705深度学习的常见模型-GAN/9.png" alt="示例图片"> </p><p><strong>二次元动漫人脸（共50个epoch）</strong><br>数据集：51223张动漫人脸，图左为原始数据集，图右为训练过程<br> <img src="/2018/07/05/20180705深度学习的常见模型-GAN/10.png" alt="示例图片"> </p><p>训练过程生成效果图如下：<br><img src="/2018/07/05/20180705深度学习的常见模型-GAN/11.png" alt="示例图片"><br><img src="/2018/07/05/20180705深度学习的常见模型-GAN/12.png" alt="示例图片"></p><p><strong>真实人脸（共100个epoch）</strong><br>数据集：CelebA 是香港中文大学的开放数据集，包含10,177个名人身份的202,599张人脸图片。（选取了25600张）,数据集如下：<br><img src="/2018/07/05/20180705深度学习的常见模型-GAN/13.png" alt="示例图片"> </p><p>训练过程生成效果图如下</p><p><img src="/2018/07/05/20180705深度学习的常见模型-GAN/14.png" alt="示例图片"><br><img src="/2018/07/05/20180705深度学习的常见模型-GAN/15.png" alt="示例图片"> </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;GAN的来源&quot;&gt;&lt;a href=&quot;#GAN的来源&quot; class=&quot;headerlink&quot; title=&quot;GAN的来源&quot;&gt;&lt;/a&gt;GAN的来源&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;2014年Goodfellow提出Generative Adversarial Nets即生成式对抗网络，它要解决的问题是如何从训练样本中学习出新样本，训练样本是图片就生成新图片，训练样本是文章就输出新文章等等。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://moyingyao.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="DL" scheme="http://moyingyao.github.io/tags/DL/"/>
    
      <category term="GAN" scheme="http://moyingyao.github.io/tags/GAN/"/>
    
  </entry>
  
  <entry>
    <title>深度学习的发展</title>
    <link href="http://moyingyao.github.io/2018/06/28/20180628%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%8F%91%E5%B1%95/"/>
    <id>http://moyingyao.github.io/2018/06/28/20180628深度学习发展/</id>
    <published>2018-06-28T14:27:24.000Z</published>
    <updated>2019-03-14T10:25:04.598Z</updated>
    
    <content type="html"><![CDATA[<h2 id="深度学习的发展历程"><a href="#深度学习的发展历程" class="headerlink" title="深度学习的发展历程"></a>深度学习的发展历程</h2><ul><li>人工智能（爷爷）</li><li>机器学习（爸爸）</li><li>深度学习（儿子）</li></ul><a id="more"></a><h3 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h3><blockquote><p>远在古希腊时期，发明家就梦想着创造能自主思考的机器。当人类第一次构思可编程计算机时，就已经在思考计算机能否变得智能（尽管这距造出第一台计算机还有一百多年）(Lovelace, 1842)。如今，人工智能（artificialintelligence, AI）已经成为一个具有众多实际应用和活跃研究课题的领域，并且正在蓬勃发展。我们期望通过智能软件自动地处理常规劳动、理解语音或图像、帮助医学诊断和支持基础科学研究。<br>一个人的日常生活需要关于世界的巨量知识。很多这方面的知识是主观的、直观的，因此很难通过形式化的方式表达清楚。计算机需要获取同样的知识才能表现出智能。人工智能的一个关键挑战就是如何将这些非形式化的知识传达给计算机。</p></blockquote><h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><blockquote><p>机器学习(Machine Learning)是一门专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构并不断改善自身性能的学科。简单来说，机器学习就是通过算法，使得机器能从大量的历史数据中学习规律，从而对新的样本做智能识别或预测未来。<br>机器学习在图像识别、语音识别、自然语言理解、天气预测、基因表达、内容推荐等很多方面的发展还存在着没有良好解决的问题。 </p></blockquote><p><img src="/2018/06/28/20180628深度学习发展/machine.jpg" alt=""></p><blockquote><p>上图是机器学习解决问题的一般流程，即将原始数据划分为训练数据和测试数据，并提取数据的特征用以训练模型，最终测试数据用来测试模型的好坏（泛化能力）。</p></blockquote><h3 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h3><blockquote><p>深度学习的概念源于人工神经网络的研究，含多隐层的多层感知机就是一种深度学习结构。深度学习通过组合低层特征形式更加抽象的高层表示属性类别或特征了，来发现数据的分布式特征表示。其动机在于建立、模拟人脑进行分析学习的神经网络，它模拟人脑的机制来解释数据，例如图像、声音和文本，深度学习是无监督学习的一种。<br>其实，神经网络早在八九十年代就被提出过，真正使得深度学习兴起有2个方面的因素：</p><ul><li>大数据，用于训练数据的增加；</li><li>计算机的算力大大增加，更快的CPU、通用GPU 的出现</li></ul></blockquote><p><img src="/2018/06/28/20180628深度学习发展/deep.jpg" alt=""></p><blockquote><p>上图是深度学习的简单结构图，主要包含三个部分：输入层（Visible layer）、隐藏层（hidden layer）和输出层（Output layer）。图中解决的是图片分类问题。<br>输入层输入图片，即像素矩阵；<br>对于隐藏层，第一层可以轻易地通过比较相邻像素的亮度来识别边缘。有了第一隐藏层描述的边缘，第二隐藏层可以容易地搜索可识别为角和扩展轮廓的边集合。给定第二隐藏层中关于角和轮廓的图像描述，第三隐藏层可以找到轮廓和角的特定集合来检测特定对象的整个部分；<br>最后根据图像描述中包含的对象部分，输出层输出图片中所包含的对象类别。</p></blockquote><h2 id="深度学习常见的编程框架"><a href="#深度学习常见的编程框架" class="headerlink" title="深度学习常见的编程框架"></a>深度学习常见的编程框架</h2><p><img src="/2018/06/28/20180628深度学习发展/d1.png" alt=""></p><blockquote><p>  观察发现，Google、Microsoft、Facebook等巨头都参与了这场深度学习框架大战，此外，还有毕业于伯克利大学的贾扬清主导开发的Caffe，蒙特利尔大学Lisa Lab团队开发的Theano，以及其他个人或商业组织贡献的框架。<br>  另外，可以看到各大主流框架基本都支持Python，目前Python在科学计算和数据挖掘领域可以说是独领风骚。虽然有来自R、Julia等语言的竞争压力，但是Python的各种库实在是太完善了，Web开发、数据可视化、数据预处理、数据库连接、爬虫等无所不能，有一个完美的生态环境。仅在数据挖据工具链上，Python就有NumPy、SciPy、Pandas、Scikit-learn、XGBoost等组件，做数据采集和预处理都非常方便，并且之后的模型训练阶段可以和TensorFlow等基于Python的深度学习框架完美衔接。</p></blockquote><h2 id="深度学习的应用"><a href="#深度学习的应用" class="headerlink" title="深度学习的应用"></a>深度学习的应用</h2><h3 id="无人驾驶"><a href="#无人驾驶" class="headerlink" title="无人驾驶"></a>无人驾驶</h3><blockquote><p>  深度学习在无人驾驶领域主要用于图像处理， 也就是摄像头上面。 当然也可以用于雷达的数据处理， 但是基于图像极大丰富的信息以及难以手工建模的特性， 深度学习能最大限度的发挥其优势。<br>  在做无人车的公司中，他们都会用到三个传感器激光雷达（lidar），测距雷达（radar）和摄像头（camera），但还是会各有侧重。比如 Waymo（前谷歌无人车）以激光雷达为主，而特斯拉和中国的图森互联以摄像头为主。我们可以从特斯拉近期放出的一段无人驾驶的视频中看到特斯拉有三个摄像头传感器，左中右各一个。</p></blockquote><p><img src="/2018/06/28/20180628深度学习发展/d2.jpg" alt=""></p><blockquote><p>从上图我们可以看出，特斯拉成功识别了道路线（红色的线）前方整个路面（右中图），这个过程就是用深度学习完成。</p></blockquote><h3 id="AlphaGo阿尔法狗"><a href="#AlphaGo阿尔法狗" class="headerlink" title="AlphaGo阿尔法狗"></a>AlphaGo阿尔法狗</h3><blockquote><p>阿尔法狗（AlphaGo）是第一个击败人类职业围棋选手、第一个战胜围棋世界冠军的人工智能程序。它主要的原理就是深度学习。<br>早在1997年，IBM的国际象棋系统深蓝，击败了世界冠军卡斯帕罗夫时，采用的算法是通过暴力搜索的方式尝试更多的下棋方法从而战胜人类，其所依赖的更多是计算机的计算资源优势。但在围棋上，深蓝的方式完全不适用。为了战胜人类围棋选手，AlphaGo需要更加智能且强大的算法。深度学习为其提供了可能。</p></blockquote><h4 id="AlphaGo主要包括三个组成部分："><a href="#AlphaGo主要包括三个组成部分：" class="headerlink" title="AlphaGo主要包括三个组成部分："></a>AlphaGo主要包括三个组成部分：</h4><blockquote><ul><li>蒙特卡洛搜索树（MonteCarlo tree search，MCTS）</li><li>估值网络（Value network）</li><li>策略网络（Policy notebook）</li></ul></blockquote><blockquote><p>AlphaGo的一个大脑——策略网络，通过深度学习在当前给定棋盘条件下，预测下一步在哪里落子。通过大量对弈棋谱获取训练数据，该网络预测人类棋手下一步落子点的准确率可达57%以上（当年数据）并可以通过自己跟自己对弈的方式提高落子水平。<br>AlphaGo的另一个大脑——估值网络，判断在当前棋盘条件下黑子赢棋的概率。其使用的数据就是策略网络自己和自己对弈时产生的。<br>AlphaGo使用蒙特卡罗树算法，根据策略网络和估值网络对局势的评判结果来寻找最佳落子点。</p></blockquote><h3 id="人脸识别"><a href="#人脸识别" class="headerlink" title="人脸识别"></a>人脸识别</h3><blockquote><p>人脸识别的方法有很多，如face++，DeepFace，FaceNet……常规的人脸识别流程为：人脸检测—&gt;对齐—&gt;表达—&gt;分类。<br>人脸对齐的方法包括以下几步：1.通过若干个特征点检测人脸；2.剪切；3.建立Delaunay triangulation;4.参考标准3d模型；5.将3d模型比对到图片上；6.进行仿射变形；7.最终生成正面图像。</p></blockquote><p><img src="/2018/06/28/20180628深度学习发展/d2.png" alt=""><br><img src="/2018/06/28/20180628深度学习发展/d3.png" alt=""></p><h2 id="学习深度学习所需的基础知识"><a href="#学习深度学习所需的基础知识" class="headerlink" title="学习深度学习所需的基础知识"></a>学习深度学习所需的基础知识</h2><blockquote><ul><li>高数（链式求导，偏导，微积分）</li><li>线代（各种矩阵变换、线性方程）</li><li>概率论（各种统计分布函数，贝叶斯，傅里叶变换）</li><li>信息论（熵，相对熵，最大熵模型）</li><li>数理统计和参数估计（中心极值定理，矩阵计算，最大似然估计）</li><li>机器学习算法（KNN,决策树，SVM）</li><li>编程语言（最好是python）</li></ul></blockquote><p><img src="/2018/06/28/20180628深度学习发展/d5.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;深度学习的发展历程&quot;&gt;&lt;a href=&quot;#深度学习的发展历程&quot; class=&quot;headerlink&quot; title=&quot;深度学习的发展历程&quot;&gt;&lt;/a&gt;深度学习的发展历程&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;人工智能（爷爷）&lt;/li&gt;
&lt;li&gt;机器学习（爸爸）&lt;/li&gt;
&lt;li&gt;深度学习（儿子）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://moyingyao.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ML" scheme="http://moyingyao.github.io/tags/ML/"/>
    
      <category term="DL" scheme="http://moyingyao.github.io/tags/DL/"/>
    
      <category term="AI" scheme="http://moyingyao.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>深度学习常见模型-CNN</title>
    <link href="http://moyingyao.github.io/2018/06/21/20180621%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%B8%B8%E8%A7%81%E6%A8%A1%E5%9E%8B-CNN/"/>
    <id>http://moyingyao.github.io/2018/06/21/20180621深度学习的常见模型-CNN/</id>
    <published>2018-06-21T14:27:24.000Z</published>
    <updated>2019-03-14T10:09:18.355Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CNN的来源"><a href="#CNN的来源" class="headerlink" title="CNN的来源"></a>CNN的来源</h3><blockquote><p>CNN由纽约大学的Yann LeCun于1989年提出。CNN本质上是一个多层感知机，其成功的原因关键在于它所采用的局部连接和共享权值的方式。</p></blockquote><a id="more"></a><blockquote><p>一方面减少了的权值的数量使得网络易于优化，另一方面降低了过拟合的风险。CNN是神经网络中的一种，它的权值共享网络结构使之更类似于生物神经网络，降低了网络模型的复杂度，减少了权值的数量。</p></blockquote><blockquote><p>权重共享：在卷积神经网络中，卷积层的每一个卷积滤波器重复的作用于整个感受野中，对输入图像进行卷积，卷积结果构成了输入图像的特征图，提取出图像的局部特征。每一个卷积滤波器共享相同的参数，包括相同的权重矩阵和偏置项。共享权重的好处是在对图像进行特征提取时不用考虑局部特征的位置。而且权重共享提供了一种有效的方式，使要学习的卷积神经网络模型参数数量大大降低。</p></blockquote><h3 id="CNN的网络架构"><a href="#CNN的网络架构" class="headerlink" title="CNN的网络架构"></a>CNN的网络架构</h3><blockquote><p>卷积神经网络结构包括：卷积层，降采样层，全链接层。每一层有多个特征图，每个特征图通过一种卷积滤波器提取输入的一种特征，每个特征图有多个神经元。</p></blockquote><h4 id="卷积层（Conv）"><a href="#卷积层（Conv）" class="headerlink" title="卷积层（Conv）"></a>卷积层（Conv）</h4><blockquote><p>这一层就是卷积神经网络最重要的一个层次，也是“卷积神经网络”名字来源。<br>在卷积层中，有两个关键操作：局部关联和窗口滑动。局部关联将每个神经元看作一个滤波器（filter），窗口滑动则使filter对局部数据进行计算。<br>除了这两个操作外，还有两个名词：步长和填充值。步长（stride）为窗口一次滑动的长度，而填充值请看下图的例子。比如有一个5x5像素大小的图片，步长取2，那么则有一个像素没有办法获取到，那应该怎么办呢？</p></blockquote><p><img src="/2018/06/21/20180621深度学习的常见模型-CNN/conv.png" alt="示例图片"></p><blockquote><p>再举一个例子，图片中输入的是一个3x4的矩阵，卷积核是一个2x2的矩阵。我们假设卷积是一次移动一个像素来操作的，那么我们首先对左上角2x2局部矩阵与卷积核进行卷积操作，即各个位置的元素相乘再相加，得到的输出矩阵S的S<sub>00</sub>的元素值为aw+bx+ey+fz。然后我们将卷积核向右平移一个像素，现在是（b,c,f,g）四个元素构成的矩阵和卷积核来卷进，得到了输出矩阵S的S<sub>01</sub>的元素，以此类推，可以得到矩阵S的S<sub>02</sub>，S<sub>10</sub>，S<sub>11</sub>，S<sub>12</sub>的元素，具体过程如下图所示。</p></blockquote><p><img src="/2018/06/21/20180621深度学习的常见模型-CNN/conv2.png" alt="示例图片"></p><blockquote><p>再举一个卷积过程的例子如下：我们有下面这个绿色的5x5输入矩阵，卷积核是一个下面这个黄色的3*3矩阵。卷积的步幅是一个像素。则卷积的过程如下面的动图。卷积的结果是一个3x3的矩阵。 </p></blockquote><p><img src="/2018/06/21/20180621深度学习的常见模型-CNN/conv3.png" alt="示例图片"></p><blockquote><p>上面举的例子都是二维的输入，卷积的过程比较简单，那么如果输入是多维的呢？比如在前面一组卷积层+池化层的输出是3个矩阵，这3个矩阵作为输入呢，那么我们怎么去卷积呢？又比如输入的是对应RGB的彩色图像，即是三个分布对应R，G和B的矩阵呢？</p></blockquote><p><img src="/2018/06/21/20180621深度学习的常见模型-CNN/conv5.png" alt="示例图片"></p><blockquote><p>这里实际输入的是3个5x5的矩阵，在原来输入的周围加上值为0的一层padding，则输入变为如图所示的7x7的矩阵。例子里面使用了两个卷积核，我们先关注与卷积核W<sub>0</sub>。由于输入的是3个7x7的矩阵，也可以说成7x7x3的张量，所以我们对应的卷积核W<sub>0</sub>的最后一个参数也必须是3的张量，这里卷积核W<sub>0</sub>的单独子矩阵维度为3x3.那么卷积核W<sub>0</sub>实际为一个3x3x3的张量。同时和上面的例子不同的是，这里的步长为2，即每次卷积后卷积核会向后移动2个像素的位置。<br><strong>蓝色矩阵（输入图像）</strong> 对 <strong>粉丝矩阵（filter）</strong> 进行矩阵内积计算并将三个内积运算的结果与偏移量b像加，比如上图中，3+0+0+0=3，计算后的值，即<strong>绿色矩阵</strong> 中的一个元素。</p></blockquote><h4 id="池化层（Pooling）"><a href="#池化层（Pooling）" class="headerlink" title="池化层（Pooling）"></a>池化层（Pooling）</h4><blockquote><p>池化层，又称为降采样层，使用的原因为：根据图像局部相关性的原理，对图像进行子采样可能减少计算量，同时保持图像的旋转不变性。相比卷积层的复杂，池化层简单的多，所谓的池化，个人理解就是对输入张量的各个子矩阵进行压缩。假如是2x2的池化滤波，那么就将子矩阵的每个2x2个元素变为一个元素；如果为3x3的池化滤波，就将子矩阵每3x3个元素变成一个元素，这样输入矩阵的维度就变小了。<br>如果想将矩阵中每NxN个元素变成一个元素，则需要一个共同的池化标准。常见的池化标准有2个：MAX和Average。即取对应区域的最大值或者平均值作为池化后的元素值。下图的例子中采用的是最大池化方法，2x2的池化滤波，步长为2.首先对红色2x2区域进行池化，此区域中最大值对6，则对应池化输出的值为6。然后滤波进行移动，由于步长为2，则移动至图中绿色区域，输出最大值为8，以此类推，最终，输入的4x4的矩阵经过池化过程后，变为2x2的矩阵，得到了压缩。</p></blockquote><p><img src="/2018/06/21/20180621深度学习的常见模型-CNN/conv7.png" alt="示例图片"></p><h4 id="全连接层（Full-Connecting）"><a href="#全连接层（Full-Connecting）" class="headerlink" title="全连接层（Full Connecting）"></a>全连接层（Full Connecting）</h4><blockquote><p>每层之间的神经元都有权重连接，通常全连接层在卷积神经网络的尾部，是同传统神经网络神经元的连接方式是一样的。全连接层和卷积层比较相似，但全连接层的输出是一个Nx1大小的向量，并通过几个全连接层对向量进行将为操作，一般采用softmax全连接。</p></blockquote><p><img src="/2018/06/21/20180621深度学习的常见模型-CNN/conv8.png" alt="示例图片"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2018/06/21/20180621深度学习的常见模型-CNN/conv9.png" alt="示例图片"></p><h4 id="一般CNN的结构依次为"><a href="#一般CNN的结构依次为" class="headerlink" title="一般CNN的结构依次为"></a>一般CNN的结构依次为</h4><blockquote><ol><li><strong>input</strong></li><li>((<strong>conv</strong> –&gt; <strong>relu</strong>) x <strong>N</strong>–&gt;pool?) x <strong>M</strong></li><li>(<strong>fc</strong> –&gt; <strong>relu</strong>) x <strong>K</strong></li><li><strong>fc</strong></li></ol></blockquote><h4 id="卷积神经网络的训练算法"><a href="#卷积神经网络的训练算法" class="headerlink" title="卷积神经网络的训练算法"></a>卷积神经网络的训练算法</h4><blockquote><ul><li>与一般的机器学习算法相比，先定义Loss function,衡量和实际结果之间的差距；</li><li>找到最小化损失函数的W（权重）和b（偏置），CNN里面最常见的算法为SGD（随机梯度下降）。</li></ul></blockquote><h4 id="卷积神经网络的优缺点"><a href="#卷积神经网络的优缺点" class="headerlink" title="卷积神经网络的优缺点"></a>卷积神经网络的优缺点</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><blockquote><ul><li>共享卷积核，便于处理高维数据；</li><li>不像机器学习人为提取特征，网络训练权重自动提取特征，且分类效果好。</li></ul></blockquote><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><blockquote><ul><li>需要大量训练样本和好的硬件支持（GPU、TPU…）;</li></ul></blockquote><blockquote><ul><li>物理含义模糊（神经网络是一种难以解释的“黑箱模型”，我们并不知道卷积层到底提取的是什么特征）。</li></ul></blockquote><h4 id="卷积神经网络的典型结构"><a href="#卷积神经网络的典型结构" class="headerlink" title="卷积神经网络的典型结构"></a>卷积神经网络的典型结构</h4><blockquote><ul><li>LeNet,最早用于手写体数字识别的卷积神经网络。</li><li>AlexNet，2012年ILSVRC比赛中获得第一名，远超过第二名，比LeNet更深，用多层小卷积层进行叠加替换大卷积层。</li><li>ZFNet，2013年ILSVRC比赛冠军</li><li>GoogleNet，2014年ILSVRC比赛冠军</li><li>VGGNet，2014年ILSVRC比赛中的模型，图像识别上略差于GoogleNet，但是在很多图像转化学习问题（比如object detection）上效果很好。</li></ul></blockquote><h3 id="实战演练"><a href="#实战演练" class="headerlink" title="实战演练"></a>实战演练</h3><p><strong>猫狗大战，即一个简单的二分类问题，训练出一个自动判别猫狗的模型</strong></p><blockquote><p>训练集（共25000张图片，猫狗各12500张）<br>测试集（共3000张图片，猫狗各1500张） </p></blockquote><p>我们通过Tensorflow这个深度学习框架来构建我们的分类网络。通过其自带的可视化工具Tensorboard我们可以看到网络的详细结构，如下左图所示。<br>模型训练完成后，我们用测试集来测试模型的泛化能力，输入一张测试图片，导入模型，输出分类结果，示例见下右图。</p><p><img src="/2018/06/21/20180621深度学习的常见模型-CNN/conv11.png" alt="示例图片"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;CNN的来源&quot;&gt;&lt;a href=&quot;#CNN的来源&quot; class=&quot;headerlink&quot; title=&quot;CNN的来源&quot;&gt;&lt;/a&gt;CNN的来源&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;CNN由纽约大学的Yann LeCun于1989年提出。CNN本质上是一个多层感知机，其成功的原因关键在于它所采用的局部连接和共享权值的方式。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://moyingyao.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="CNN" scheme="http://moyingyao.github.io/tags/CNN/"/>
    
      <category term="DL" scheme="http://moyingyao.github.io/tags/DL/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper</title>
    <link href="http://moyingyao.github.io/2018/06/08/20180608zookeeper/"/>
    <id>http://moyingyao.github.io/2018/06/08/20180608zookeeper/</id>
    <published>2018-06-08T13:54:25.000Z</published>
    <updated>2019-03-14T09:04:54.791Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，它是集群的管理者，监视着集群中各个节点的状态根据节点提交的反馈进行下一步合理操作。最终，将简单易用的接口和性能高效、功能稳定的系统提供给用户。zookeeper主要是写分布式程序，可总结为：一致、有头、数据数。<br><a id="more"></a></p></blockquote><h1 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h1><blockquote><p>使用zookeeper开发自己的分布式系统要注意的问题：</p><ol><li>解决数据一致性的问题</li><li>协调各种“动物”<br>hadoop  小象<br>impala  黑斑羚<br>shark   鲨鱼<br>hive    蜂巢<br>mahout  象夫<br>zookeeper 动物园管理员</li></ol></blockquote><h1 id="google三论文"><a href="#google三论文" class="headerlink" title="google三论文"></a>google三论文</h1><blockquote><p>GFS → HDFS<br>BigTable → HBase<br>MapReduce → HadoopMR<br>chubby → zookeeper</p></blockquote><h1 id="zookeeper是什么？"><a href="#zookeeper是什么？" class="headerlink" title="zookeeper是什么？"></a>zookeeper是什么？</h1><blockquote><p>NoSQL数据库<br>CAP原理</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，它是集群的管理者，监视着集群中各个节点的状态根据节点提交的反馈进行下一步合理操作。最终，将简单易用的接口和性能高效、功能稳定的系统提供给用户。zookeeper主要是写分布式程序，可总结为：一致、有头、数据数。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://moyingyao.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="大数据" scheme="http://moyingyao.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="zookeeper" scheme="http://moyingyao.github.io/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>memcached安装及简单命令</title>
    <link href="http://moyingyao.github.io/2018/06/05/20180605memcached%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E5%91%BD%E4%BB%A4/"/>
    <id>http://moyingyao.github.io/2018/06/05/20180605memcached安装及简单命令/</id>
    <published>2018-06-05T12:09:14.000Z</published>
    <updated>2019-03-14T09:04:26.791Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>memcached是一套分布式的高速缓存系统，由LiveJournal的Brad Fitzpatrick开发，但目前被许多网站使用。</p></blockquote><h1 id="ubuntu16-0-4下memcached的安装"><a href="#ubuntu16-0-4下memcached的安装" class="headerlink" title="ubuntu16.0.4下memcached的安装"></a>ubuntu16.0.4下memcached的安装</h1><a id="more"></a><blockquote><p>linux系统安装memcached首先要安装libevent库</p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install libevent-deve</span><br><span class="line">sudo apt-<span class="builtin-name">get</span> install memcached</span><br></pre></td></tr></table></figure><blockquote><p>若linux系统为centos则命令为<br>linux系统安装memcached首先要安装libevent库</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> libevent libevent-deve</span><br><span class="line">yum <span class="keyword">install</span> memcached</span><br></pre></td></tr></table></figure><h1 id="memcached的连接与关闭"><a href="#memcached的连接与关闭" class="headerlink" title="memcached的连接与关闭"></a>memcached的连接与关闭</h1><h2 id="启动memcached连接"><a href="#启动memcached连接" class="headerlink" title="启动memcached连接"></a>启动memcached连接</h2><blockquote><p>找到memcached的安装目录，自动安装memcached在/usr/local/bin/memcached路径下<br>linux系统安装memcached首先要安装libevent库</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memcached -u root -d -m <span class="number">128</span>m -p <span class="number">11211</span></span><br></pre></td></tr></table></figure><blockquote><p>连接memcached语法为：telnet HOST PORT<br>本实例的memcached服务运行的主机为127.0.0.1(本机)，端口为11211<br>linux系统安装memcached首先要安装libevent库</p></blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">11211</span></span><br></pre></td></tr></table></figure><blockquote><p>连接成功如下图所示：</p></blockquote><p><img src="https://i.imgur.com/jLWKbvn.png" alt=""><br><strong>退出命令</strong></p><blockquote><p>linux系统安装memcached首先要安装libevent库</p></blockquote><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">quit</span></span><br></pre></td></tr></table></figure><h2 id="关闭memcached"><a href="#关闭memcached" class="headerlink" title="关闭memcached"></a>关闭memcached</h2><blockquote><p>与windows直接输入memcached.exe -d stop关闭memcached不同<br>linux需先知道memcached的进程号，再将其杀死<br>查看进程号<br>linux系统安装memcached首先要安装libevent库</p></blockquote><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stats     或者     <span class="keyword">ps</span> -ef|<span class="keyword">grep</span> memcached</span><br></pre></td></tr></table></figure><blockquote><p>知道了memcached对应的进程号pid后，使用kill命令杀死进程即可。<br>注意：杀死进程前必须quit退出连接<br>linux系统安装memcached首先要安装libevent库</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> 5070</span><br></pre></td></tr></table></figure><blockquote><p>杀死进城后再次连接memcached失败，说明memcached已经被关闭。</p></blockquote><h1 id="memcached的命令"><a href="#memcached的命令" class="headerlink" title="memcached的命令"></a>memcached的命令</h1><h2 id="存储命令"><a href="#存储命令" class="headerlink" title="存储命令"></a>存储命令</h2><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><blockquote><p>set用于将value存储于key中，若set的key已经存在，该命令可以更新key所对应的原来的数据。语法格式如下：<br>linux系统安装memcached首先要安装libevent库</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">key</span> flag exptime <span class="keyword">bytes</span> [noreply]</span><br><span class="line"><span class="keyword">value</span></span><br></pre></td></tr></table></figure><blockquote><p>key：键值对中的key，用于查找缓存值<br>flag：可以包含键值对的整型参数，客户机使用它存储关于键值对的额外信息<br>exptime：再缓存中保存键值对的时间长度，以秒为单位，0表示永远<br>bytes：在缓存中存储的字节数<br>noreply：可选参数，该参数告知服务器不需要返回数据<br>value：存储的值，始终位于第二行</p></blockquote><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><blockquote><p>add用于将value存储在指定的key中，如果add的key已经存在，则不会更新数据，与之前的值仍然保持相同，会得到NOT_STORED的响应，但是过期的key会更新。<br>语法格式如下：<br>linux系统安装memcached首先要安装libevent库</p></blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add</span><span class="bash"> key flags exptime bytes [noreply]</span></span><br><span class="line"><span class="bash">value</span></span><br></pre></td></tr></table></figure><h3 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h3><blockquote><p>replace用于替换已经存在的key的value，如果可以不存在，则替换失败，并且得到NOT_STORED的响应<br>语法格式如下：<br>linux系统安装memcached首先要安装libevent库</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">replace</span> <span class="keyword">key</span> flags exptime <span class="keyword">bytes</span> [noreply]</span><br><span class="line"><span class="keyword">value</span></span><br></pre></td></tr></table></figure><h3 id="append"><a href="#append" class="headerlink" title="append"></a>append</h3><blockquote><p>append用于向已经存在key的value后面追加数据<br>语法格式如下：<br>linux系统安装memcached首先要安装libevent库</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">append key flags exptime <span class="keyword">bytes</span> [noreply]</span><br><span class="line"><span class="built_in">value</span></span><br></pre></td></tr></table></figure><h3 id="prepend"><a href="#prepend" class="headerlink" title="prepend"></a>prepend</h3><blockquote><p>prepend命令用于向已经存在key的value前面追加数据<br>语法格式如下：<br>linux系统安装memcached首先要安装libevent库</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prepend key flags exptime <span class="keyword">bytes</span> [noreply]</span><br><span class="line"><span class="built_in">value</span></span><br></pre></td></tr></table></figure><h3 id="cas"><a href="#cas" class="headerlink" title="cas"></a>cas</h3><blockquote><p>cas用于执行一个“检查并设置”的操作，它仅在当前客户端最后一次取值后，该key对应的值没有被其他客户端修改的情况下才能够将值写入。检查是通过cas_token参数进行的，这个参数是memcached指定给已经存在的元素的一个唯一的64位值。<br>语法格式如下：<br>linux系统安装memcached首先要安装libevent库</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cas key flags exptime <span class="keyword">bytes</span> unique_cas_token [noreply]</span><br><span class="line"><span class="built_in">value</span></span><br></pre></td></tr></table></figure><blockquote><p>unique_cas_token是通过gets命令获取的一个唯一的64位值</p></blockquote><h2 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h2><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><blockquote><p>get用于获取存储在key中的value，如果key不存在，则返回空。若获取多个key的value，则使用空格将其隔开即可。<br>语法格式如下：<br>linux系统安装memcached首先要安装libevent库</p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">get</span> key</span><br><span class="line"><span class="builtin-name">get</span> key1 key2 key3</span><br></pre></td></tr></table></figure><h3 id="gets"><a href="#gets" class="headerlink" title="gets"></a>gets</h3><blockquote><p>gets用于获取CAS令牌存的value,如果key不存在，则返回空。若获取多个key的value，则使用空格将其隔开即可。<br>语法格式如下：<br>linux系统安装memcached首先要安装libevent库</p></blockquote><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">gets</span> key</span><br><span class="line"><span class="keyword">gets</span> key1 key2 key3</span><br></pre></td></tr></table></figure><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><blockquote><p>delete命令用于删除已经存在的key。<br>语法格式如下：<br>linux系统安装memcached首先要安装libevent库</p></blockquote><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="built_in">key</span> [noreply]</span><br></pre></td></tr></table></figure><h3 id="incr-decr"><a href="#incr-decr" class="headerlink" title="incr/decr"></a>incr/decr</h3><blockquote><p>incr和decr用于对已经存在的key的数字进行自增或自减操作。但是惭怍的数据必须是十进制的32位无符号整数，若key不存在，返回NOT_FOUND，若键的值不为数字，则返回CLIENT_ERROR，其他错误返回ERROR。<br>语法格式如下：<br>linux系统安装memcached首先要安装libevent库</p></blockquote><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">incr key increment_values <span class="string">[noreply]</span></span><br><span class="line">decr key decrement_values <span class="string">[noreply]</span></span><br></pre></td></tr></table></figure><blockquote><p>increment_values为增加的数值<br>decrement_values为减少的数值</p></blockquote><h3 id="flush-all"><a href="#flush-all" class="headerlink" title="flush_all"></a>flush_all</h3><blockquote><p>flush_all用于清理缓存中的所有的键值对，该命令提供了一个可选参数time，用于在制定的时间后执行清理缓存操作。<br>语法格式如下：<br>linux系统安装memcached首先要安装libevent库</p></blockquote><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush_all <span class="string">[time]</span> <span class="string">[noreply]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;memcached是一套分布式的高速缓存系统，由LiveJournal的Brad Fitzpatrick开发，但目前被许多网站使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;ubuntu16-0-4下memcached的安装&quot;&gt;&lt;a href=&quot;#ubuntu16-0-4下memcached的安装&quot; class=&quot;headerlink&quot; title=&quot;ubuntu16.0.4下memcached的安装&quot;&gt;&lt;/a&gt;ubuntu16.0.4下memcached的安装&lt;/h1&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://moyingyao.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="大数据" scheme="http://moyingyao.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="memcached" scheme="http://moyingyao.github.io/tags/memcached/"/>
    
  </entry>
  
  <entry>
    <title>redis安装及简单命令</title>
    <link href="http://moyingyao.github.io/2018/06/02/20180602redis%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E5%91%BD%E4%BB%A4/"/>
    <id>http://moyingyao.github.io/2018/06/02/20180602redis安装及简单命令/</id>
    <published>2018-06-02T08:45:50.000Z</published>
    <updated>2019-03-14T09:02:14.906Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>redis是一个key-value存储系统。它支持存储的value类型相对更很多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。<br><a id="more"></a><br>Redis是一个高性能的key-value数据库。 redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部分场合可以对关系数据库起到很好的补充作用。它提供了Java，C/C++，C#，PHP，JavaScript，Perl，Object-C，Python，Ruby，Erlang等客户端，使用很方便。</p></blockquote><h1 id="Redis：REmote-DIctionary-Server"><a href="#Redis：REmote-DIctionary-Server" class="headerlink" title="Redis：REmote DIctionary Server"></a>Redis：REmote DIctionary Server</h1><h2 id="Redis-远程字典服务器"><a href="#Redis-远程字典服务器" class="headerlink" title="Redis(远程字典服务器)"></a>Redis(远程字典服务器)</h2><blockquote><p>是完全开源免费的，用C语言编写，是一个高性能的（key/value）分布式内存数据库，基于内存运行并支持持久化的NoSQL数据库，是当前最热门的NoSQL数据库之一，也被人们称之为结构数据服务器。</p></blockquote><h2 id="Redis逐步取代memcached的原因"><a href="#Redis逐步取代memcached的原因" class="headerlink" title="Redis逐步取代memcached的原因"></a>Redis逐步取代memcached的原因</h2><blockquote><p>1.redis支持数据持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用<br>2.redis不仅仅直迟简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储<br>3.redis支持数据的备份，即master-slave魔术的数据备份</p></blockquote><h2 id="Redis能做什么？"><a href="#Redis能做什么？" class="headerlink" title="Redis能做什么？"></a>Redis能做什么？</h2><blockquote><p>1.内存存储和持久化：redis支持异步将内存中的数据写到硬盘上，同时不影响继续服务<br>2.取最新N个数据的操作，如：可以将最新的10条评论的ID放在redis的List集合里面<br>3.模拟类似于HttpSession这种需要设定过期时间的功能<br>4.发布、订阅消息系统<br>5.定时器、计数器</p></blockquote><h2 id="与memcached区别"><a href="#与memcached区别" class="headerlink" title="与memcached区别"></a>与memcached区别</h2><blockquote><p>都是key-value存储<br>memcached一旦服务关闭，数据会全部没有<br>redis服务关闭重启后数据还在</p></blockquote><h1 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h1><blockquote><p>我们的环境：<br>VMware Workplace<br>CentOS-6.5<br>redis-4.0.9<br>下载地址： Http://redis.io<br>将下载好的redis-4.0.9放入虚拟机中，并解压</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">tar</span> <span class="selector-tag">-zxvf</span> <span class="selector-tag">redis-4</span><span class="selector-class">.9</span><span class="selector-class">.0</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br></pre></td></tr></table></figure><blockquote><p>redis内包含的文件</p></blockquote><p><img src="https://i.imgur.com/inuGfQx.png" alt=""></p><blockquote><p>输入命令</p></blockquote><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">make</span></span><br></pre></td></tr></table></figure><blockquote><p>运行运行makefile文件，要有GCC，没有则会报错。<br>安装gcc：</p></blockquote><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">yum</span> <span class="comment">install</span> <span class="comment">gcc</span><span class="literal">-</span><span class="comment">c</span><span class="literal">+</span><span class="literal">+</span></span><br></pre></td></tr></table></figure><blockquote><p>安装完成之后要进行二次make，但是之前要将上一次make不成功的残余文件清理，之后再make</p></blockquote><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span> disclean</span><br><span class="line"><span class="built_in">make</span></span><br></pre></td></tr></table></figure><blockquote><p>make完成后，执行</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make <span class="keyword">install</span></span><br></pre></td></tr></table></figure><blockquote><p>出现下图所示即安装成功</p></blockquote><p><img src="https://i.imgur.com/pbUT2FT.png" alt=""></p><h1 id="配置redis-conf"><a href="#配置redis-conf" class="headerlink" title="配置redis.conf"></a>配置redis.conf</h1><blockquote><p>进入redis-4.0.9,将redis.conf拷贝一份，在拷贝后的上面进行修改<br>将redis.conf拷贝至myredis文件夹下</p></blockquote><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vim</span> redis.<span class="keyword">conf</span></span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/ThxbeJV.png" alt=""></p><blockquote><p>将no修改为yes</p></blockquote><h1 id="启动redis服务"><a href="#启动redis服务" class="headerlink" title="启动redis服务"></a>启动redis服务</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/bin</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/kWyradG.png" alt=""><br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /<span class="built_in">home</span>/myy/hadoop/myredis/redis.<span class="built_in">config</span></span><br></pre></td></tr></table></figure></p><p><img src="https://i.imgur.com/yJIzrIU.png" alt=""></p><h1 id="进入客户端"><a href="#进入客户端" class="headerlink" title="进入客户端"></a>进入客户端</h1><blockquote><p>客户端默认端口为6379</p></blockquote><p><img src="https://i.imgur.com/7tzwWOB.png" alt=""></p><blockquote><p>判断是否与服务端连接成功</p></blockquote><p><img src="https://i.imgur.com/w0CV6tg.png" alt=""></p><blockquote><p>查看服务状态</p></blockquote><p><img src="https://i.imgur.com/bli2295.png" alt=""></p><blockquote><p>关闭连接</p></blockquote><p><img src="https://i.imgur.com/CX3oEJZ.png" alt=""></p><blockquote><p>关闭后查看服务就没有了</p></blockquote><p><img src="https://i.imgur.com/IiXkIPf.png" alt=""></p><h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><h2 id="默认库"><a href="#默认库" class="headerlink" title="默认库"></a>默认库</h2><blockquote><p>Redis默认有16个库，进入时默认在0号库，角标从0开始，某些任务找一号库，某些找二号库，任务逻辑更清晰redis.conf中有说明</p></blockquote><p><img src="https://i.imgur.com/BU29JJY.png" alt=""></p><blockquote><p>转换库的命令，eg：切换为8号库</p></blockquote><p><img src="https://i.imgur.com/J2FGtCY.png" alt=""></p><h2 id="flushdb和flushall的区别"><a href="#flushdb和flushall的区别" class="headerlink" title="flushdb和flushall的区别"></a>flushdb和flushall的区别</h2><blockquote><p>flushdb是删除当前库，flushall是删除全部库</p></blockquote><h2 id="Benchmark查看本机状态"><a href="#Benchmark查看本机状态" class="headerlink" title="Benchmark查看本机状态"></a>Benchmark查看本机状态</h2><p><img src="https://i.imgur.com/Z2Q0Fv3.png" alt=""><img src="https://i.imgur.com/7z1VOWO.png" alt=""><img src="https://i.imgur.com/i9NWdjz.png" alt=""><img src="https://i.imgur.com/LmtfECg.png" alt=""><img src="https://i.imgur.com/MXCvvnS.png" alt=""></p><h1 id="常用五大数据类型"><a href="#常用五大数据类型" class="headerlink" title="常用五大数据类型"></a>常用五大数据类型</h1><h2 id="string字符串"><a href="#string字符串" class="headerlink" title="string字符串"></a>string字符串</h2><blockquote><p>String是redis最基本的类型，可以理解为与memcached一摸一样的类型，一个key对应一个value。<br>String类型是二进制安全的，即redis的string可以包含任何数据，比如jpg图片或者序列化对象<br>string是redis最基本的数据类型，一个redis中字符串最多可以是512M</p></blockquote><h2 id="hash哈希"><a href="#hash哈希" class="headerlink" title="hash哈希"></a>hash哈希</h2><blockquote><p>redis hash是一个键值对集合，是一个string类型的filed和value的映射表，适合用于存储对象。<br>类似java中的Map&lt;String,Object&gt;</p></blockquote><h2 id="list列表"><a href="#list列表" class="headerlink" title="list列表"></a>list列表</h2><blockquote><p>列表是简单的字符串列表，按照插入顺利排序。可以添加一个元素到列表的头部（左边）或者尾部（右边），它的底层实际是个链表</p></blockquote><h2 id="set集合"><a href="#set集合" class="headerlink" title="set集合"></a>set集合</h2><blockquote><p>set是string类型的无序集合。是通过HashTable实现的。</p></blockquote><h2 id="Zset有序集合"><a href="#Zset有序集合" class="headerlink" title="Zset有序集合"></a>Zset有序集合</h2><blockquote><p>Zset（sorted set）<br>zset和set一样也是string类型元素的集合，且不允许重复的成员。<br>不同的是每个元素都会关联一个double类型的分数。<br>redis正是通过分数来为集合中的成员进行从小到大的排序。zset的承宣是唯一的，但分数（score）是可以重复的。</p></blockquote><h1 id="常用关键字"><a href="#常用关键字" class="headerlink" title="常用关键字"></a>常用关键字</h1><h2 id="set-get-exists-keys-move-mset-mget"><a href="#set-get-exists-keys-move-mset-mget" class="headerlink" title="set/get/exists/keys/move/mset/mget"></a>set/get/exists/keys/move/mset/mget</h2><blockquote><p>set设置键值，也可以覆盖原来的值<br>get获取对应键的值<br>exists查看某个key是否存在<br>move移动到别的库内<br>mset/mget批量设置/获取键值</p></blockquote><p><img src="https://i.imgur.com/iM55rsZ.png" alt=""><img src="https://i.imgur.com/AiFg5Jl.png" alt=""><img src="https://i.imgur.com/L0raU11.png" alt=""><img src="https://i.imgur.com/6aAYxKL.png" alt=""></p><h2 id="expire-ttl-setex"><a href="#expire-ttl-setex" class="headerlink" title="expire/ttl/setex"></a>expire/ttl/setex</h2><blockquote><p>expire设置秒数，过期后自动消失<br>ttl 查看某个key还有多久时间<br>setex设置值时同时设置时间</p></blockquote><p><img src="https://i.imgur.com/qAMGzHT.png" alt=""><img src="https://i.imgur.com/AAWcCWc.png" alt=""></p><h2 id="append-strlen-getrange-setrange-incr-decr-incrby-decrby"><a href="#append-strlen-getrange-setrange-incr-decr-incrby-decrby" class="headerlink" title="append/strlen/getrange/setrange/incr/decr/incrby/decrby"></a>append/strlen/getrange/setrange/incr/decr/incrby/decrby</h2><blockquote><p>append补充字符串<br>strlen字符串的长度<br>getrange获取指定区域范围内的值，0到-1表示全部<br>setrange设置指定区域范围内的值<br>incr递增加1<br>decr递减少1<br>incrby   decrby自定义数量<br>string类型此命令不可用</p></blockquote><p><img src="https://i.imgur.com/UjpKfJa.png" alt=""><img src="https://i.imgur.com/0Tqgcyz.png" alt=""><img src="https://i.imgur.com/Erl8ku1.png" alt=""></p><h2 id="lpush-lrange-lpop-rpop-lidex-llen"><a href="#lpush-lrange-lpop-rpop-lidex-llen" class="headerlink" title="lpush/lrange/lpop/rpop/lidex/llen"></a>lpush/lrange/lpop/rpop/lidex/llen</h2><blockquote><p>lpush和rpush查看后顺序不同<br>lrange查看list<br>lpop栈顶出去<br>rpop栈底出去<br>lidex索引<br>llen查看list长度</p></blockquote><p><img src="https://i.imgur.com/SmiHEoI.png" alt=""><img src="https://i.imgur.com/QSJZtGe.png" alt=""><img src="https://i.imgur.com/13DBD6n.png" alt=""></p><h2 id="lren-ltrim-rpoplpush-lset-linsert"><a href="#lren-ltrim-rpoplpush-lset-linsert" class="headerlink" title="lren/ltrim/rpoplpush/lset/linsert"></a>lren/ltrim/rpoplpush/lset/linsert</h2><blockquote><p>lrem删除n和value<br>ltrim截取指定范围内的值再赋值给list<br>rpoplpush将list01栈底给list02栈顶<br>lset替换某位置的值<br>linsert某值之前或之后插入某值</p></blockquote><p><img src="https://i.imgur.com/hxDg2SU.png" alt=""><img src="https://i.imgur.com/mXG2x8p.png" alt=""><img src="https://i.imgur.com/RF5E1Vy.png" alt=""><img src="https://i.imgur.com/zguZHDx.png" alt=""><img src="https://i.imgur.com/nO5lZGc.png" alt=""></p><h2 id="sadd-smembers-sismember-scard-srem-srandmember"><a href="#sadd-smembers-sismember-scard-srem-srandmember" class="headerlink" title="sadd/smembers/sismember/scard/srem/srandmember"></a>sadd/smembers/sismember/scard/srem/srandmember</h2><blockquote><p>sadd设置set集合（重复自动留一个）<br>smembers查看set集合<br>sismember查看set内是否有某值<br>scard获取集合内元素个数<br>srem删除集合内某值<br>srandmember集合中随机出几个数</p></blockquote><p><img src="https://i.imgur.com/toMNESc.png" alt=""><img src="https://i.imgur.com/NeBJIHu.png" alt=""><img src="https://i.imgur.com/QSZbjLr.png" alt=""><img src="https://i.imgur.com/GZ37ulu.png" alt=""></p><h2 id="spop-smove-sdiff-sinter-sunion"><a href="#spop-smove-sdiff-sinter-sunion" class="headerlink" title="spop/smove/sdiff/sinter/sunion"></a>spop/smove/sdiff/sinter/sunion</h2><blockquote><p>spop随机出栈<br>smove将一set中某一值<br>赋给另一set<br>sdiff取两集合的差集：在第一个中而不在第二个中<br>sinter取两集合的交集<br>sunion取两集合的并集</p></blockquote><p><img src="https://i.imgur.com/XyQXNW7.png" alt=""><img src="https://i.imgur.com/dRWsJJV.png" alt=""><img src="https://i.imgur.com/u6TdF2U.png" alt=""></p><h2 id="zrange-zrevrange-zcount"><a href="#zrange-zrevrange-zcount" class="headerlink" title="zrange/zrevrange/zcount"></a>zrange/zrevrange/zcount</h2><blockquote><p>zrange同list相同<br>zrevrange从高到低排序<br>zincrby修改某个值的分数<br>zcount返回指定分数范围内值的个数</p></blockquote><p><img src="https://i.imgur.com/q7suFVE.png" alt=""><img src="https://i.imgur.com/EqTjeHX.png" alt=""><img src="https://i.imgur.com/wQCzN1l.png" alt=""><img src="https://i.imgur.com/10VijR6.png" alt=""></p><h2 id="hash相关的关键字"><a href="#hash相关的关键字" class="headerlink" title="hash相关的关键字"></a>hash相关的关键字</h2><blockquote><p>kv模式不变，但v是一个键值对</p></blockquote><p><img src="https://i.imgur.com/GGPPbYV.png" alt=""><img src="https://i.imgur.com/JnBAXGt.png" alt=""><img src="https://i.imgur.com/EUYBanW.png" alt=""><img src="https://i.imgur.com/KUlb3nd.png" alt=""><img src="https://i.imgur.com/jO0YeHh.png" alt=""><img src="https://i.imgur.com/JEnzQND.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;redis是一个key-value存储系统。它支持存储的value类型相对更很多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://moyingyao.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="大数据" scheme="http://moyingyao.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="redis" scheme="http://moyingyao.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>hadoop 分布式搭建</title>
    <link href="http://moyingyao.github.io/2018/05/30/20180530hadoop-%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%AD%E5%BB%BA/"/>
    <id>http://moyingyao.github.io/2018/05/30/20180530hadoop-分布式搭建/</id>
    <published>2018-05-30T07:58:55.000Z</published>
    <updated>2019-03-14T08:57:39.715Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Hadoop实现了一个分布式文件系统（Hadoop Distributed File System），简称HDFS。HDFS有高容错性的特点，并且设计用来部署在低廉的（low-cost）硬件上；而且它提供高吞吐量（high throughput）来访问应用程序的数据，适合那些有着超大数据集（large data set）的应用程序。HDFS放宽了（relax）POSIX的要求，可以以流的形式访问（streaming access）文件系统中的数据。Hadoop的框架最核心的设计就是：HDFS和MapReduce。HDFS为海量的数据提供了存储，而MapReduce则为海量的数据提供了计算。<br>下面我们一起来搭建吧。<br><a id="more"></a></p></blockquote><h1 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h1><blockquote><p>linux环境下搭建hadoop集群需要准备：<br>VMware-workstation-10.0.1注册机<br>CentOS-6.5-x86_64-bin-DVD1<br>jdk-7u79-linux-x64<br>hadoop-2.6.4.tar</p></blockquote><p><img src="https://i.imgur.com/vrtN7JU.png" alt=""></p><h1 id="新建虚拟机"><a href="#新建虚拟机" class="headerlink" title="新建虚拟机"></a>新建虚拟机</h1><blockquote><p>解压VMware-workstation-10.0.1注册机,打开VMware Workstation主页,点击新建虚拟机,选择典型,如下:<br><img src="https://i.imgur.com/Wbzensp.png" alt=""><br>点击下一步,选择安装程序光盘映像文件,浏览找到你下载CentOS-6.5-x86_64-bin-DVD1的压缩包文件,如下:<br><img src="https://i.imgur.com/IzWxBjV.png" alt=""><br>继续点击下一步,填写用户名和密码(尽量简单),填好后点击下一步,为即将创建的虚拟机命名并选择安装路径(最好不要安装在C盘),如下所示:<br><img src="https://i.imgur.com/hjdvvqZ.png" alt=""><br>继续点击下一步至如下界面:<br><img src="https://i.imgur.com/chMAScN.png" alt=""><br>点击自定义硬件可以修改虚拟机的各项参数,如果电脑内存小于等于4GB,需要将内存改至512MB,否则严重卡顿。修改完成后点击完成，虚拟机就创建成功，打开后界面如下：<br><img src="https://i.imgur.com/RlJpVk3.png" alt=""><br>若要批量创建虚拟机，可以在创建好的虚拟机的基础上进行克隆操作，<br><img src="https://i.imgur.com/lbyJLai.png" alt=""></p></blockquote><h1 id="安装jdk"><a href="#安装jdk" class="headerlink" title="安装jdk"></a>安装jdk</h1><blockquote><p>打开一个虚拟机，右键单击桌面选择Open in Terminal，进入编辑界面：</p></blockquote><h2 id="假设用户名为wxx"><a href="#假设用户名为wxx" class="headerlink" title="假设用户名为wxx"></a>假设用户名为wxx</h2><h3 id="获取root权限"><a href="#获取root权限" class="headerlink" title="获取root权限"></a>获取root权限</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">su  </span><br><span class="line"><span class="keyword">cd</span> <span class="string">/etc</span></span><br><span class="line">vi sudoers</span><br></pre></td></tr></table></figure><blockquote><p>i 进入编辑状态，在</p></blockquote><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root <span class="keyword">ALL</span>=(<span class="keyword">ALL</span>)</span><br></pre></td></tr></table></figure><blockquote><p>ALL的下一行编辑</p></blockquote><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wxx  <span class="keyword">ALL</span>=(<span class="keyword">ALL</span>) <span class="keyword">ALL</span></span><br></pre></td></tr></table></figure><blockquote><p>按ESC键，退出编辑格式<br>按Shift + :<br>输入wq!保存并退出</p></blockquote><h3 id="创建hadoop文件夹"><a href="#创建hadoop文件夹" class="headerlink" title="创建hadoop文件夹"></a>创建hadoop文件夹</h3><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span></span><br><span class="line"><span class="built_in">mkdir</span>  hadoop</span><br></pre></td></tr></table></figure><blockquote><p>将jdk-7u79-linux-x64安装包复制到hadoop文件目录下（与windows环境下类似）。</p></blockquote><h3 id="解压jdk-7u79-linux-x64-gz文件"><a href="#解压jdk-7u79-linux-x64-gz文件" class="headerlink" title="解压jdk-7u79-linux-x64.gz文件"></a>解压jdk-7u79-linux-x64.gz文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span></span><br><span class="line"><span class="built_in">cd</span> hadoop</span><br><span class="line">tar-zxvf jdk-7u79-linux-x64.gz</span><br></pre></td></tr></table></figure><h3 id="设置jdk环境变量"><a href="#设置jdk环境变量" class="headerlink" title="设置jdk环境变量"></a>设置jdk环境变量</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span></span><br><span class="line"><span class="keyword">cd</span>  hadoop</span><br><span class="line">su</span><br><span class="line">gedit <span class="string">/etc/profile</span></span><br></pre></td></tr></table></figure><blockquote><p>进入后在最后一行添加以下指令：</p></blockquote><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=<span class="regexp">/home/by</span><span class="regexp">/hadoop/jdk</span>1.<span class="number">8.0_11</span></span><br><span class="line">export PATH=$JAVA_HOME/<span class="symbol">bin:</span>$PATH</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/<span class="class"><span class="keyword">lib</span>/<span class="title">dt</span>.<span class="title">jar</span>:$<span class="title">JAVA_HOME</span>/<span class="title">lib</span>/<span class="title">tools</span>.<span class="title">jar</span></span></span><br></pre></td></tr></table></figure><blockquote><p>点击保存后关闭，输入以下指令使jdk生效：</p></blockquote><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">source</span> <span class="regexp">/etc/</span>profile</span><br></pre></td></tr></table></figure><h3 id="检查jdk是否安装成功"><a href="#检查jdk是否安装成功" class="headerlink" title="检查jdk是否安装成功"></a>检查jdk是否安装成功</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -<span class="built_in">version</span></span><br></pre></td></tr></table></figure><blockquote><p>成功后显示如下信息：</p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java version <span class="string">"1.7.0_79"</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.7.0_79-b15)</span><br><span class="line">Java HotSpot(TM) 64-Bit<span class="built_in"> Server </span>VM (build 24.79-b02, mixed mode)</span><br></pre></td></tr></table></figure><h1 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h1><h2 id="克隆虚拟机"><a href="#克隆虚拟机" class="headerlink" title="克隆虚拟机"></a>克隆虚拟机</h2><blockquote><p>将已经安装好jdk的虚拟机克隆两个，创建三个虚拟机的集群。</p></blockquote><h2 id="修改hostname"><a href="#修改hostname" class="headerlink" title="修改hostname"></a>修改hostname</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su</span><br><span class="line">vi  <span class="regexp">/etc/</span>sysconfig<span class="regexp">/network</span></span><br></pre></td></tr></table></figure><blockquote><p>将三个虚拟机分别命名master、slave1、slave2<br>如图：</p></blockquote><p><img src="https://i.imgur.com/wUQ1xjq.png" alt=""></p><blockquote><p>完成后重启虚拟机reboot</p></blockquote><h2 id="将三个虚拟机的ip地址相互连接"><a href="#将三个虚拟机的ip地址相互连接" class="headerlink" title="将三个虚拟机的ip地址相互连接"></a>将三个虚拟机的ip地址相互连接</h2><blockquote><p>首先必须确保虚拟机联网，如果NET模式连不上网，则选中桥接模式。<br>网络通畅后执行以下操作:<br>1.查看三台虚拟机IP,分别对三个虚拟机执行指令ifconfig，查看各虚拟机ip地址</p></blockquote><blockquote><p>2.在master中执行以下指令</p></blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">su</span><br><span class="line">cd/etc</span><br><span class="line">gedit /etc/hosts <span class="number">192.168</span><span class="number">.142</span><span class="number">.142</span> <span class="number">192.168</span><span class="number">.142</span><span class="number">.143</span></span><br></pre></td></tr></table></figure><blockquote><p>进入编辑界面后按“IP地址   hostname”填写信息，如图：</p></blockquote><p><img src="https://i.imgur.com/O1rxMcZ.png" alt=""></p><blockquote><p>填写完后按Save按钮，关闭编辑页。</p></blockquote><blockquote><p>3.将配置好的文件复制到slave1、slave2中,在master中执行以下指令：</p></blockquote><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp /etc/hosts root<span class="variable">@slave1</span><span class="symbol">:/etc/</span></span><br><span class="line">scp /etc/hosts root<span class="variable">@slave2</span><span class="symbol">:/etc/</span></span><br></pre></td></tr></table></figure><blockquote><p>4.检查各虚拟机是否互联,在master中执行以下指令：</p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ping slave1</span><br><span class="line">ping slave2</span><br></pre></td></tr></table></figure><blockquote><p>连通即完成</p></blockquote><h2 id="配置SSH无密钥登录"><a href="#配置SSH无密钥登录" class="headerlink" title="配置SSH无密钥登录"></a>配置SSH无密钥登录</h2><blockquote><p>1.关闭防火墙,对每个虚拟机进行如下操作：</p></blockquote><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su</span><br><span class="line"><span class="attribute">chkconfig</span> iptables <span class="literal">off</span></span><br></pre></td></tr></table></figure><blockquote><p>执行后重启虚拟机： </p></blockquote><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">reboot</span></span><br></pre></td></tr></table></figure><blockquote><p>2.关闭防火墙后在master下执行以下指令：</p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd</span><br><span class="line">ssh-keygen –t rsa</span><br><span class="line">cd  .ssh</span><br><span class="line">cat  id_rsa.pub  <span class="meta">&gt;&gt;  </span>authorized_keys</span><br><span class="line">chmod  <span class="number">600</span>  authorized_keys </span><br><span class="line">scp  authorized_keys  wxx@slave1<span class="symbol">:~/</span>.ssh/</span><br><span class="line">scp  authorized_keys  wxx@slave2<span class="symbol">:~/</span>.ssh/</span><br></pre></td></tr></table></figure><blockquote><p>3.检查无密钥登录是否成功</p></blockquote><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh slave1</span><br><span class="line">ssh slave2</span><br><span class="line">ssh  <span class="literal">master</span></span><br></pre></td></tr></table></figure><blockquote><p>成功后显示如下：</p></blockquote><p><img src="https://i.imgur.com/I25emLH.png" alt=""></p><h2 id="安装并配置hadoop-2-6-4-在master中"><a href="#安装并配置hadoop-2-6-4-在master中" class="headerlink" title="安装并配置hadoop-2.6.4(在master中)"></a>安装并配置hadoop-2.6.4(在master中)</h2><blockquote><p>1.将hadoop-2.6.4.tar.gz安装包复制到hadoop文件目录下（与windows环境下类似）。</p></blockquote><blockquote><p>2.解压hadoop-2.6.4.tar.gz</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">cd</span></span><br><span class="line"><span class="selector-tag">cd</span> <span class="selector-tag">hadoop</span></span><br><span class="line"><span class="selector-tag">tar</span> <span class="selector-tag">-zxvf</span> <span class="selector-tag">hadoop-2</span><span class="selector-class">.6</span><span class="selector-class">.4</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br></pre></td></tr></table></figure><blockquote><p>3.配置hadoop-2.6.4的各项文件</p></blockquote><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span></span><br><span class="line"><span class="keyword">cd</span> hadoop/hadoop-2.7.4</span><br><span class="line"><span class="keyword">cd</span> etc/hadoop</span><br><span class="line">gedit hadoop-env.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure><blockquote><p>在最后一行添加:</p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">JAVA_HOME</span>=/home/by/hadoop/ jdk1.8.0_11</span><br></pre></td></tr></table></figure><h3 id="编辑core-site-xml"><a href="#编辑core-site-xml" class="headerlink" title="编辑core-site.xml"></a>编辑core-site.xml</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">gedit</span> <span class="selector-tag">core-site</span><span class="selector-class">.xml</span></span><br></pre></td></tr></table></figure><blockquote><p>添加代码：</p></blockquote><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">&lt;property&gt;</span></span><br><span class="line"><span class="params">&lt;name&gt;</span>fs.default.name<span class="params">&lt;/name&gt;</span></span><br><span class="line"><span class="params">&lt;value&gt;</span>hdfs:<span class="comment">//master:9000&lt;/value&gt;</span></span><br><span class="line"><span class="params">&lt;final&gt;</span>true<span class="params">&lt;/final&gt;</span></span><br><span class="line"><span class="params">&lt;/property&gt;</span></span><br><span class="line"><span class="params">&lt;property&gt;</span></span><br><span class="line"><span class="params">&lt;name&gt;</span>hadoop.tmp.dir<span class="params">&lt;/name&gt;</span></span><br><span class="line"><span class="params">&lt;value&gt;</span><span class="meta-keyword">/home/</span>by<span class="meta-keyword">/hadoop/</span>tmp<span class="params">&lt;/value&gt;</span></span><br><span class="line"><span class="params">&lt;/property&gt;</span></span><br><span class="line"><span class="params">&lt;property&gt;</span></span><br><span class="line"><span class="params">&lt;name&gt;</span>ds.default.name<span class="params">&lt;/name&gt;</span></span><br><span class="line"><span class="params">&lt;value&gt;</span>hdfs:<span class="comment">//master:54310&lt;/value&gt;</span></span><br><span class="line"><span class="params">&lt;final&gt;</span>true<span class="params">&lt;/final&gt;</span></span><br><span class="line"><span class="params">&lt;/property&gt;</span></span><br></pre></td></tr></table></figure><h3 id="编辑hdfs-site-xml"><a href="#编辑hdfs-site-xml" class="headerlink" title="编辑hdfs-site.xml"></a>编辑hdfs-site.xml</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">gedit</span> <span class="selector-tag">hdfs-site</span><span class="selector-class">.xml</span></span><br></pre></td></tr></table></figure><blockquote><p>添加代码：</p></blockquote><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">&lt;property&gt;</span></span><br><span class="line"><span class="params">&lt;name&gt;</span>dfs.namenode.name.dir<span class="params">&lt;/name&gt;</span></span><br><span class="line"><span class="params">&lt;value&gt;</span>file:<span class="meta-keyword">/home/</span>by<span class="meta-keyword">/hadoop/</span>dfs/name<span class="params">&lt;/value&gt;</span></span><br><span class="line"><span class="params">&lt;final&gt;</span>true<span class="params">&lt;/final&gt;</span></span><br><span class="line"><span class="params">&lt;/property&gt;</span></span><br><span class="line"><span class="params">&lt;property&gt;</span></span><br><span class="line"><span class="params">&lt;name&gt;</span>dfs.datanode.data.dir<span class="params">&lt;/name&gt;</span></span><br><span class="line"><span class="params">&lt;value&gt;</span>file:<span class="meta-keyword">/home/</span>by<span class="meta-keyword">/hadoop/</span>dfs/data<span class="params">&lt;/value&gt;</span></span><br><span class="line"><span class="params">&lt;final&gt;</span>true<span class="params">&lt;/final&gt;</span></span><br><span class="line"><span class="params">&lt;/property&gt;</span></span><br><span class="line"><span class="params">&lt;property&gt;</span></span><br><span class="line"><span class="params">&lt;name&gt;</span>dfs.replication<span class="params">&lt;/name&gt;</span></span><br><span class="line"><span class="params">&lt;value&gt;</span><span class="number">2</span><span class="params">&lt;/value&gt;</span></span><br><span class="line"><span class="params">&lt;/property&gt;</span></span><br></pre></td></tr></table></figure><h3 id="编辑mapred-site-xml"><a href="#编辑mapred-site-xml" class="headerlink" title="编辑mapred-site.xml"></a>编辑mapred-site.xml</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">gedit</span> <span class="selector-tag">mapred-site</span><span class="selector-class">.xml</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：必须先复制mapred-site.xml.template文件更名为mapred-site.xml<br>添加代码：</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>master:10020<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.webapp.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>master:19888<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="编辑yarn-site-xml"><a href="#编辑yarn-site-xml" class="headerlink" title="编辑yarn-site.xml"></a>编辑yarn-site.xml</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">gedit</span>  <span class="selector-tag">yarn-site</span><span class="selector-class">.xml</span></span><br></pre></td></tr></table></figure><blockquote><p>添加代码：</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services.mapreduce.shuffle.class<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>org.apache.hadoop.mapred.ShuffleHandler<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>master<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>master:8032<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.scheduler.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>master:8030<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.resource-tracker.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>master:8031<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.admin.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>master:8033<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.webapp.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>master:8088<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="编辑master"><a href="#编辑master" class="headerlink" title="编辑master"></a>编辑master</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gedit <span class="literal">master</span></span><br></pre></td></tr></table></figure><blockquote><p>添加代码：</p></blockquote><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">master</span></span><br></pre></td></tr></table></figure><h3 id="编辑slaves"><a href="#编辑slaves" class="headerlink" title="编辑slaves"></a>编辑slaves</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gedit slaves</span></span><br></pre></td></tr></table></figure><blockquote><p>添加代码：</p></blockquote><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">master</span></span><br><span class="line">slave1</span><br><span class="line">slave2</span><br></pre></td></tr></table></figure><blockquote><p>4.将配置好的文件复制到slave1、slave2中</p></blockquote><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> </span><br><span class="line"><span class="keyword">cd</span> hadoop</span><br><span class="line">scp -r hadoop-2.7.4 slave1:~<span class="string">/hadoop</span></span><br><span class="line">scp -r hadoop-2.7.4 slave2:~<span class="string">/hadoop</span></span><br></pre></td></tr></table></figure><blockquote><p>5.启动集群</p></blockquote><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span></span><br><span class="line"><span class="built_in">cd</span>  hadoop/hadoop-<span class="number">2</span>.<span class="number">7</span>.<span class="number">4</span></span><br><span class="line">bin/hdfs namenode  -<span class="built_in">format</span></span><br><span class="line">sbin/<span class="built_in">start</span>-dfs.sh</span><br><span class="line">sbin/<span class="built_in">start</span>-yarn.sh</span><br><span class="line">sbin/hadoop-daemon.sh  <span class="built_in">start</span>  secondarynamenode</span><br></pre></td></tr></table></figure><blockquote><p>6.检查集群情况</p></blockquote><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">jps</span></span><br></pre></td></tr></table></figure><blockquote><p>三台虚拟机如下所示：</p></blockquote><p><img src="https://i.imgur.com/Y1KfeJY.png" alt=""><br><img src="https://i.imgur.com/VlP3QMy.png" alt=""><br><img src="https://i.imgur.com/7Nsazie.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Hadoop实现了一个分布式文件系统（Hadoop Distributed File System），简称HDFS。HDFS有高容错性的特点，并且设计用来部署在低廉的（low-cost）硬件上；而且它提供高吞吐量（high throughput）来访问应用程序的数据，适合那些有着超大数据集（large data set）的应用程序。HDFS放宽了（relax）POSIX的要求，可以以流的形式访问（streaming access）文件系统中的数据。Hadoop的框架最核心的设计就是：HDFS和MapReduce。HDFS为海量的数据提供了存储，而MapReduce则为海量的数据提供了计算。&lt;br&gt;下面我们一起来搭建吧。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://moyingyao.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="hadoop" scheme="http://moyingyao.github.io/tags/hadoop/"/>
    
      <category term="大数据" scheme="http://moyingyao.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>LaTeX入门</title>
    <link href="http://moyingyao.github.io/2018/05/27/20180527LaTeX%E5%85%A5%E9%97%A8/"/>
    <id>http://moyingyao.github.io/2018/05/27/20180527LaTeX入门/</id>
    <published>2018-05-27T07:04:26.000Z</published>
    <updated>2019-03-14T08:54:53.745Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>LaTeX是一种基于ΤΕΧ的排版系统，由美国计算机学家莱斯利·兰伯特（Leslie Lamport）在20世纪80年代初期开发，利用这种格式，即使使用者没有排版和程序设计的知识也可以充分发挥由TeX所提供的强大功能，能在几天，甚至几小时内生成很多具有书籍质量的印刷品。对于生成复杂表格和数学公式，这一点表现得尤为突出。因此它非常适用于生成高印刷质量的科技和数学类文档。这个系统同样适用于生成从简单的信件到完整书籍的所有其他种类的文档。我们在投稿论文的时候，会经常使用LaTex根据期刊的要求对文章进行排版，所以作为一名研究生学习这个是十分必要的。<br><a id="more"></a></p></blockquote><h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><blockquote><p>打开WinEdt，建立一个新文档，将以下内容复制进入文档中，保存，保存类型选择为UTF-8。</p></blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span>  </span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span>  </span><br><span class="line">hello, world  </span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>然后在WinEdt的工具栏中找到编译按钮（在垃圾桶和字母B中间），在下拉菜单中选择XeTeX，并点击编译。<br>如果顺利的话，就可以顺利生成出第一个pdf文件，点击工具栏中的放大镜按钮就可以快速打开生成的pdf文件。 </p></blockquote><h1 id="标题、作者、章节和段落"><a href="#标题、作者、章节和段落" class="headerlink" title="标题、作者、章节和段落"></a>标题、作者、章节和段落</h1><blockquote><p>建立一个新文档，将以下内容复制进入文档中，保存，保存类型选择为UTF-8，编译并观察现象。</p></blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span>  </span><br><span class="line"><span class="tag">\<span class="name">author</span><span class="string">&#123;My Name&#125;</span></span>  </span><br><span class="line"><span class="tag">\<span class="name">title</span><span class="string">&#123;The Title&#125;</span></span>  </span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span>  </span><br><span class="line"><span class="tag">\<span class="name">maketitle</span></span>  </span><br><span class="line">hello, world <span class="comment">% This is comment  </span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>效果图如下：</p></blockquote><p><img src="https://i.imgur.com/KPP0wzq.png" alt=""> </p><h1 id="加入目录"><a href="#加入目录" class="headerlink" title="加入目录"></a>加入目录</h1><blockquote><p>建立一个新文档，将以下内容复制进入文档中，保存，保存类型选择为UTF-8，编译并观察现象。</p></blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span>  </span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span>  </span><br><span class="line"><span class="tag">\<span class="name">tableofcontents</span></span>  </span><br><span class="line"><span class="tag">\<span class="name">section</span><span class="string">&#123;Hello China&#125;</span></span> China is in East Asia.  </span><br><span class="line"><span class="tag">\<span class="name">subsection</span><span class="string">&#123;Hello Beijing&#125;</span></span> Beijing is the capital of China.  </span><br><span class="line"><span class="tag">\<span class="name">subsubsection</span><span class="string">&#123;Hello Dongcheng District&#125;</span></span>  </span><br><span class="line"><span class="tag">\<span class="name">paragraph</span><span class="string">&#123;Hello Tian'anmen Square&#125;</span></span>is in the center of Beijing  </span><br><span class="line"><span class="tag">\<span class="name">subparagraph</span><span class="string">&#123;Hello Chairman Mao&#125;</span></span> is in the center of Tian'anmen Square  </span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>效果图如下：</p></blockquote><p><img src="https://i.imgur.com/5KAaLd6.png" alt=""> </p><h1 id="段落和换行"><a href="#段落和换行" class="headerlink" title="段落和换行"></a>段落和换行</h1><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">\documentclass&#123;article&#125;</span>  </span><br><span class="line"><span class="string">\begin&#123;document&#125;</span>  </span><br><span class="line">Beijing <span class="keyword">is</span>  </span><br><span class="line">the capital  </span><br><span class="line"><span class="keyword">of</span> China.  </span><br><span class="line">  </span><br><span class="line">New York <span class="keyword">is</span>  </span><br><span class="line">  </span><br><span class="line">the capital  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">of</span> America.  </span><br><span class="line">  </span><br><span class="line">Amsterdam <span class="keyword">is</span> <span class="string">\\</span> the capital <span class="string">\\</span>  </span><br><span class="line"><span class="keyword">of</span> Netherlands.  </span><br><span class="line"><span class="string">\end&#123;document&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>效果图如下：</p></blockquote><p><img src="https://i.imgur.com/Rpk6Hh2.png" alt=""></p><h1 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h1><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span>  </span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;amsmath&#125;</span></span>  </span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;amssymb&#125;</span></span>  </span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span>  </span><br><span class="line">The Newton's second law is F=ma.  </span><br><span class="line">  </span><br><span class="line">The Newton's second law is <span class="formula">$F=ma$</span>.  </span><br><span class="line">  </span><br><span class="line">The Newton's second law is  </span><br><span class="line">F=ma</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">The Newton's second law is  </span><br><span class="line">F=ma</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">Greek Letters <span class="formula">$<span class="tag">\<span class="name">eta</span></span>$</span> and <span class="formula">$<span class="tag">\<span class="name">mu</span></span>$</span>  </span><br><span class="line">  </span><br><span class="line">Fraction <span class="formula">$<span class="tag">\<span class="name">frac</span><span class="string">&#123;a&#125;</span><span class="string">&#123;b&#125;</span></span>$</span>  </span><br><span class="line">  </span><br><span class="line">Power <span class="formula">$a^b$</span>  </span><br><span class="line">  </span><br><span class="line">Subscript <span class="formula">$a_b$</span>  </span><br><span class="line">  </span><br><span class="line">Derivate <span class="formula">$<span class="tag">\<span class="name">frac</span><span class="string">&#123;\partial y&#125;</span><span class="string">&#123;\partial t&#125;</span></span> $</span>  </span><br><span class="line">  </span><br><span class="line">Vector <span class="formula">$<span class="tag">\<span class="name">vec</span><span class="string">&#123;n&#125;</span></span>$</span>  </span><br><span class="line">  </span><br><span class="line">Bold <span class="formula">$<span class="tag">\<span class="name">mathbf</span><span class="string">&#123;n&#125;</span></span>$</span>  </span><br><span class="line">  </span><br><span class="line">To time differential <span class="formula">$<span class="tag">\<span class="name">dot</span><span class="string">&#123;F&#125;</span></span>$</span>  </span><br><span class="line">  </span><br><span class="line">Matrix (lcr here means left, center or right for each column)  </span><br><span class="line"><span class="tag">\<span class="name">[</span></span>  </span><br><span class="line"><span class="tag">\<span class="name">left</span><span class="string">[  </span></span></span><br><span class="line"><span class="tag"><span class="string">\begin&#123;array&#125;&#123;lcr&#125;  </span></span></span><br><span class="line"><span class="tag"><span class="string">a1 &amp; b22 &amp; c333 \\  </span></span></span><br><span class="line"><span class="tag"><span class="string">d444 &amp; e555555 &amp; f6  </span></span></span><br><span class="line"><span class="tag"><span class="string">\end&#123;array&#125;  </span></span></span><br><span class="line"><span class="tag"><span class="string">\right]</span></span>  </span><br><span class="line"><span class="tag">\<span class="name">]</span></span>  </span><br><span class="line">  </span><br><span class="line">Equations(here <span class="tag">\<span class="name">&amp;</span></span> is the symbol for aligning different rows)  </span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;align&#125;</span></span>  </span><br><span class="line">a+b&amp;=c<span class="tag">\<span class="name">\</span></span>  </span><br><span class="line">d&amp;=e+f+g  </span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;align&#125;</span></span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">\<span class="name">[</span></span>  </span><br><span class="line"><span class="tag">\<span class="name">left</span></span><span class="tag">\<span class="name">&#123;</span></span>  </span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;aligned&#125;</span></span>  </span><br><span class="line">&amp;a+b=c<span class="tag">\<span class="name">\</span></span>  </span><br><span class="line">&amp;d=e+f+g  </span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;aligned&#125;</span></span>  </span><br><span class="line"><span class="tag">\<span class="name">right</span></span>.  </span><br><span class="line"><span class="tag">\<span class="name">]</span></span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>效果图如下：</p></blockquote><p><img src="https://i.imgur.com/JCSYPxO.png" alt=""></p><h1 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h1><blockquote><p>先搜索到一个将图片转成eps文件的软件，很容易找的，然后将图片保存为一个名字如figure1.eps。<br>建立一个新文档，将以下内容复制进入文档中，保存，保存类型选择为UTF-8，放在和图片文件同一个文件夹里，编<br>译并观察现象。</p></blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span>  </span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;graphicx&#125;</span></span>  </span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span>  </span><br><span class="line"><span class="tag">\<span class="name">includegraphics</span><span class="string">[width=4.00in,height=3.00in]</span><span class="string">&#123;figure1.eps&#125;</span></span>  </span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure><h1 id="简单表格"><a href="#简单表格" class="headerlink" title="简单表格"></a>简单表格</h1><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;tabular&#125;</span><span class="string">&#123;|c|c|&#125;</span></span></span><br><span class="line">a &amp; b <span class="tag">\<span class="name">\</span></span></span><br><span class="line">c &amp; d<span class="tag">\<span class="name">\</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;tabular&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;tabular&#125;</span><span class="string">&#123;|c|c|&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">hline</span></span></span><br><span class="line">a &amp; b <span class="tag">\<span class="name">\</span></span></span><br><span class="line"><span class="tag">\<span class="name">hline</span></span></span><br><span class="line">c &amp; d<span class="tag">\<span class="name">\</span></span></span><br><span class="line"><span class="tag">\<span class="name">hline</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;tabular&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;center&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;tabular&#125;</span><span class="string">&#123;|c|c|&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">hline</span></span></span><br><span class="line">a &amp; b <span class="tag">\<span class="name">\</span></span> <span class="tag">\<span class="name">hline</span></span></span><br><span class="line">c &amp; d<span class="tag">\<span class="name">\</span></span></span><br><span class="line"><span class="tag">\<span class="name">hline</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;tabular&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;center&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>效果图如下：</p></blockquote><p><img src="https://i.imgur.com/JoYKa5s.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;LaTeX是一种基于ΤΕΧ的排版系统，由美国计算机学家莱斯利·兰伯特（Leslie Lamport）在20世纪80年代初期开发，利用这种格式，即使使用者没有排版和程序设计的知识也可以充分发挥由TeX所提供的强大功能，能在几天，甚至几小时内生成很多具有书籍质量的印刷品。对于生成复杂表格和数学公式，这一点表现得尤为突出。因此它非常适用于生成高印刷质量的科技和数学类文档。这个系统同样适用于生成从简单的信件到完整书籍的所有其他种类的文档。我们在投稿论文的时候，会经常使用LaTex根据期刊的要求对文章进行排版，所以作为一名研究生学习这个是十分必要的。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LaTeX" scheme="http://moyingyao.github.io/categories/LaTeX/"/>
    
    
      <category term="LaTeX" scheme="http://moyingyao.github.io/tags/LaTeX/"/>
    
      <category term="文档编写" scheme="http://moyingyao.github.io/tags/%E6%96%87%E6%A1%A3%E7%BC%96%E5%86%99/"/>
    
  </entry>
  
  <entry>
    <title>机器学习实战--决策树</title>
    <link href="http://moyingyao.github.io/2018/05/25/20180525%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <id>http://moyingyao.github.io/2018/05/25/20180525机器学习实战-决策树/</id>
    <published>2018-05-25T02:32:28.000Z</published>
    <updated>2019-03-14T08:53:15.098Z</updated>
    
    <content type="html"><![CDATA[<h1 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h1><blockquote><p>优点：计算复杂度不高，输出结果易于理解，对中间值的缺失不敏感，可以处理不相关特诊数据<br>缺点：可能会产生过度匹配问题<br>使用数据类型：数值型和标称型<br>专家系统中，经常使用决策树<br><a id="more"></a></p></blockquote><h1 id="trees-py"><a href="#trees-py" class="headerlink" title="trees.py"></a>trees.py</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> log</span><br><span class="line"><span class="keyword">import</span> operator</span><br></pre></td></tr></table></figure><h2 id="createDataSet"><a href="#createDataSet" class="headerlink" title="createDataSet()"></a>createDataSet()</h2><blockquote><p>创建数据集</p></blockquote><h1 id="trees-py-1"><a href="#trees-py-1" class="headerlink" title="trees.py"></a>trees.py</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createDataSet</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 数据集中两个特征'no surfacing','flippers', 数据的两个类标签'yes','no</span></span><br><span class="line">    <span class="comment">#dataSet是个list</span></span><br><span class="line">    dataSet = [[<span class="number">1</span>, <span class="number">1</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">1</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">0</span>, <span class="string">'no'</span>],</span><br><span class="line">               [<span class="number">0</span>, <span class="number">1</span>, <span class="string">'no'</span>],</span><br><span class="line">               [<span class="number">0</span>, <span class="number">1</span>, <span class="string">'no'</span>]]</span><br><span class="line">    labels = [<span class="string">'no surfacing'</span>,<span class="string">'flippers'</span>]</span><br><span class="line">    <span class="keyword">return</span> dataSet, labels</span><br></pre></td></tr></table></figure><h2 id="calcShannonEnt-dataSet"><a href="#calcShannonEnt-dataSet" class="headerlink" title="calcShannonEnt(dataSet)"></a>calcShannonEnt(dataSet)</h2><blockquote><p>计算给定数据集的熵</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcShannonEnt</span><span class="params">(dataSet)</span>:</span></span><br><span class="line">    numEntries = len(dataSet)   <span class="comment">#计算数据集中实例的总数</span></span><br><span class="line">    labelCounts = &#123;&#125;            <span class="comment">#创建空字典</span></span><br><span class="line">    <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:     <span class="comment">#提取数据集每一行的特征向量</span></span><br><span class="line">        currentLabel = featVec[<span class="number">-1</span>]  <span class="comment">#获取特征向量最后一列的标签</span></span><br><span class="line">        <span class="comment"># 检测字典的关键字key中是否存在该标签，如果不存在keys()关键字，将当前标签/0键值对存入字典中,并赋值为0</span></span><br><span class="line">        <span class="comment">#print(labelCounts.keys())</span></span><br><span class="line">        <span class="keyword">if</span> currentLabel <span class="keyword">not</span> <span class="keyword">in</span> labelCounts.keys(): labelCounts[currentLabel] = <span class="number">0</span></span><br><span class="line">        <span class="comment">#print(labelCounts)</span></span><br><span class="line">        labelCounts[currentLabel] += <span class="number">1</span>  <span class="comment">#否则将当前标签对应的键值加1</span></span><br><span class="line">        <span class="comment">#print("%s="%currentLabel,labelCounts[currentLabel])</span></span><br><span class="line">    shannonEnt = <span class="number">0.0</span>    <span class="comment">#初始化熵为0</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> labelCounts:</span><br><span class="line">        prob = float(labelCounts[key])/numEntries   <span class="comment">#计算各值出现的频率</span></span><br><span class="line">        shannonEnt -= prob * log(prob,<span class="number">2</span>)    <span class="comment">#以2为底求对数再乘以出现的频率，即信息期望值</span></span><br><span class="line">        <span class="comment">#print("%s="%labelCounts[key],shannonEnt)</span></span><br><span class="line">    <span class="keyword">return</span> shannonEnt</span><br></pre></td></tr></table></figure><h2 id="splitDataSet-dataSet-axis-value"><a href="#splitDataSet-dataSet-axis-value" class="headerlink" title="splitDataSet(dataSet, axis, value)"></a>splitDataSet(dataSet, axis, value)</h2><blockquote><p>按照给定特征划分数据集<br>得到熵之后，还需划分数据集，以便判断当前是否正确地划分了数据集，三个输入参数分别为：带划分的数据集，划分数据集的特征，需要返回的特征得值，挑选出dataSet中axis位置值为value的剩余部分。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">splitDataSet</span><span class="params">(dataSet, axis, value)</span>:</span></span><br><span class="line">    retDataSet = []</span><br><span class="line">    <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:</span><br><span class="line">        <span class="keyword">if</span> featVec[axis] == value:  <span class="comment">#筛选出dataSet中axis位置值为value</span></span><br><span class="line">           <span class="comment">#列表的索引中冒号的作用，a[1: ]表示该列表中的第1个元素到最后一个元素，而a[ : n]表示从第0歌元素到第n个元素(不包括n)</span></span><br><span class="line">           reducedFeatVec = featVec[:axis] <span class="comment">#取出特定位置前面部分并赋值给reducedFeatVec</span></span><br><span class="line">           <span class="comment">#print(featVec[axis+1:])</span></span><br><span class="line">           <span class="comment">#print(reducedFeatVec)</span></span><br><span class="line">           reducedFeatVec.extend(featVec[axis+<span class="number">1</span>:])     <span class="comment">#取出特定位置后面部分并赋值给reducedFeatVec</span></span><br><span class="line">           retDataSet.append(reducedFeatVec)</span><br><span class="line">           <span class="comment">#print(retDataSet)</span></span><br><span class="line">    <span class="keyword">return</span> retDataSet</span><br></pre></td></tr></table></figure><h2 id="chooseBestFeatureToSplit-dataSet"><a href="#chooseBestFeatureToSplit-dataSet" class="headerlink" title="chooseBestFeatureToSplit(dataSet)"></a>chooseBestFeatureToSplit(dataSet)</h2><blockquote><p>选择最好的数据集划分方式<br>选取特征，划分数据集，计算得出最好的划分数据集的特征</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chooseBestFeatureToSplit</span><span class="params">(dataSet)</span>:</span></span><br><span class="line">    numFeatures = len(dataSet[<span class="number">0</span>]) - <span class="number">1</span>      <span class="comment">#计算特征数量，即每一列表元素具有的列数，再减去最后一列为标签，故需减去1</span></span><br><span class="line">    baseEntropy = calcShannonEnt(dataSet)       <span class="comment">#计算信息熵，此处值为0.9709505944546686，此值将与划分之后的数据集计算的信息熵进行比较</span></span><br><span class="line">    bestInfoGain = <span class="number">0.0</span>;bestFeature = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(numFeatures):</span><br><span class="line">        featList = [example[i] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]      <span class="comment">#创建标签列表</span></span><br><span class="line">        <span class="comment">#print(featList)</span></span><br><span class="line">        uniqueVals = set(featList)       <span class="comment">#确定某一特征下所有可能的取值,set集合类型中的每个值互不相同</span></span><br><span class="line">        <span class="comment">#print(uniqueVals)</span></span><br><span class="line">        newEntropy = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:        <span class="comment">#计算每种划分方式的信息熵</span></span><br><span class="line">           subDataSet = splitDataSet(dataSet, i, value)        <span class="comment">#抽取该特征的每个取值下其他特征的值组成新的子数据集</span></span><br><span class="line">           prob = len(subDataSet)/float(len(dataSet))      <span class="comment">#计算该特征下的每一个取值对应的概率（或者说所占的比重）</span></span><br><span class="line">           newEntropy += prob * calcShannonEnt(subDataSet)     <span class="comment">#计算该特征下每一个取值的子数据集的信息熵，并求和</span></span><br><span class="line">        infoGain = baseEntropy - newEntropy     <span class="comment">#计算每个特征的信息增益</span></span><br><span class="line">        <span class="comment">#print("第%d个特征是的取值是%s，对应的信息增益值是%f"%((i+1),uniqueVals,infoGain))</span></span><br><span class="line">        <span class="keyword">if</span> (infoGain &gt; bestInfoGain):</span><br><span class="line">           bestInfoGain = infoGain</span><br><span class="line">           bestFeature = i</span><br><span class="line">           <span class="comment">#print("第%d个特征的信息增益最大，所以选择它作为划分的依据，其特征的取值为%s,对应的信息增益值是%f"%((i+1),uniqueVals,infoGain))</span></span><br><span class="line">    <span class="keyword">return</span> bestFeature</span><br></pre></td></tr></table></figure><h2 id="majorityCnt-classList"><a href="#majorityCnt-classList" class="headerlink" title="majorityCnt(classList)"></a>majorityCnt(classList)</h2><blockquote><p>递归构建决策树，返回出现次数最多的分类名称</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityCnt</span><span class="params">(classList)</span>:</span></span><br><span class="line">   classCount=&#123;&#125;</span><br><span class="line">   <span class="keyword">for</span> vote <span class="keyword">in</span> classList:</span><br><span class="line">       <span class="keyword">if</span> vote <span class="keyword">not</span> <span class="keyword">in</span> classCount.keys(): classCount[vote] = <span class="number">0</span></span><br><span class="line">       classCount[vote] += <span class="number">1</span></span><br><span class="line">   sortedClassCount = sorted(classCount.iteritems(), key=operator.itemgetter(<span class="number">1</span>), reverse=<span class="keyword">True</span>)</span><br><span class="line">   <span class="keyword">return</span> sortedClassCount[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2 id="createTree-dataSet-labels"><a href="#createTree-dataSet-labels" class="headerlink" title="createTree(dataSet,labels)"></a>createTree(dataSet,labels)</h2><blockquote><p>创建树,参数为数据集和标签列表</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createTree</span><span class="params">(dataSet,labels)</span>:</span></span><br><span class="line">    classList = [example[<span class="number">-1</span>] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]       <span class="comment">#提取dataset中的最后一列——种类标签</span></span><br><span class="line">    <span class="comment">#print(classList)</span></span><br><span class="line">    <span class="keyword">if</span> classList.count(classList[<span class="number">0</span>]) == len(classList):    <span class="comment">#计算classlist[0]出现的次数,如果相等，说明都是属于一类，不用继续往下划分</span></span><br><span class="line">       <span class="keyword">return</span> classList[<span class="number">0</span>]     <span class="comment">#递归结束的第一个条件是所有的类标签完全相同，则直接返回该类标签</span></span><br><span class="line">   <span class="comment">#print(dataSet[0])</span></span><br><span class="line">   <span class="keyword">if</span> len(dataSet[<span class="number">0</span>]) == <span class="number">1</span>: <span class="comment">#看还剩下多少个属性，如果只有一个属性，但是类别标签有多个，就直接用majoritycnt()进行整理，选取类别最多的作为返回值</span></span><br><span class="line">       <span class="keyword">return</span> majorityCnt(classList)   <span class="comment">#递归结束的第二个条件是使用完了所有的特征，仍然不能将数据集划分成仅包含唯一类别的分组，则返回出现次数最多的类别</span></span><br><span class="line">   bestFeat = chooseBestFeatureToSplit(dataSet)    <span class="comment">#选取信息增益最大的特征作为下一次分类的依据</span></span><br><span class="line">   bestFeatLabel = labels[bestFeat]     <span class="comment">#选取特征对应的标签</span></span><br><span class="line">   <span class="comment">#print(bestFeatLabel)</span></span><br><span class="line">   myTree = &#123;bestFeatLabel:&#123;&#125;&#125;  <span class="comment">#创建tree字典，下一个特征位于第二个大括号内，循环递归</span></span><br><span class="line">   <span class="keyword">del</span>(labels[bestFeat])   <span class="comment">#删除使用过的特征</span></span><br><span class="line">   featValues = [example[bestFeat] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]     <span class="comment">#特征值对应的该栏数据</span></span><br><span class="line">   <span class="comment">#print(featValues)</span></span><br><span class="line">    uniqueVals = set(featValues)    <span class="comment">#找到featvalues所包含的所有元素，去重复</span></span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:</span><br><span class="line">       subLabels = labels[:]        <span class="comment">#将使用过的标签删除更新后，赋值给新的列表，进行迭代</span></span><br><span class="line">       <span class="comment">#print(subLabels)</span></span><br><span class="line">       myTree[bestFeatLabel][value] = createTree(splitDataSet(dataSet, bestFeat,value),subLabels) <span class="comment">#循环递归生成树</span></span><br><span class="line">   <span class="keyword">return</span> myTree</span><br></pre></td></tr></table></figure><h2 id="classify-inputTree-featLabels-testVec"><a href="#classify-inputTree-featLabels-testVec" class="headerlink" title="classify(inputTree,featLabels,testVec):"></a>classify(inputTree,featLabels,testVec):</h2><blockquote><p>测试算法，使用决策树执行分类</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classify</span><span class="params">(inputTree,featLabels,testVec)</span>:</span></span><br><span class="line">   firstStr = list(inputTree.keys())[<span class="number">0</span>]    <span class="comment">#找到树的第一个分类特征，或者说根节点'no surfacing'</span></span><br><span class="line">   <span class="comment">#print(firstStr)</span></span><br><span class="line">   secondDict = inputTree[firstStr]    <span class="comment">#从树中得到该分类特征的分支，有0和1</span></span><br><span class="line">   <span class="comment">#print(secondDict)</span></span><br><span class="line">   featIndex = featLabels.index(firstStr)  <span class="comment">#根据分类特征的索引找到对应的标称型数据值，'no surfacing'对应的索引为0</span></span><br><span class="line">    <span class="comment">#print(featIndex)</span></span><br><span class="line">    key = testVec[featIndex]</span><br><span class="line">    valueOfFeat = secondDict[key]</span><br><span class="line">    <span class="keyword">if</span> isinstance(valueOfFeat, dict): </span><br><span class="line">       classLabel = classify(valueOfFeat, featLabels, testVec)</span><br><span class="line">    <span class="keyword">else</span>: classLabel = valueOfFeat</span><br><span class="line">    <span class="keyword">return</span> classLabel</span><br></pre></td></tr></table></figure><h2 id="storeTree-inputTree-filename"><a href="#storeTree-inputTree-filename" class="headerlink" title="storeTree(inputTree,filename)"></a>storeTree(inputTree,filename)</h2><blockquote><p>决策树的存储，使用pickle序列化对象，可在磁盘中保存对象。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">storeTree</span><span class="params">(inputTree,filename)</span>:</span></span><br><span class="line">   <span class="keyword">import</span> pickle</span><br><span class="line">   fw = open(filename,<span class="string">'wb'</span>)    <span class="comment">#二进制写入'wb'</span></span><br><span class="line">   pickle.dump(inputTree,fw)   <span class="comment">#pickle的dump函数将决策树写入文件中</span></span><br><span class="line">   fw.close()</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grabTree</span><span class="params">(filename)</span>:</span></span><br><span class="line">   <span class="keyword">import</span> pickle</span><br><span class="line">   fr = open(filename,<span class="string">'rb'</span>)    <span class="comment">#对应于二进制方式写入数据，'rb'采用二进制形式读出数据</span></span><br><span class="line">   <span class="keyword">return</span> pickle.load(fr)</span><br></pre></td></tr></table></figure><h1 id="trees-main-py"><a href="#trees-main-py" class="headerlink" title="trees_main.py"></a>trees_main.py</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> trees</span><br><span class="line"><span class="keyword">from</span> imp <span class="keyword">import</span> reload</span><br><span class="line"><span class="keyword">import</span> treePlotter</span><br></pre></td></tr></table></figure><h2 id="创建数据集"><a href="#创建数据集" class="headerlink" title="创建数据集"></a>创建数据集</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myDat,labels=trees.createDataSet()</span><br><span class="line"><span class="comment">#print(myDat)</span></span><br><span class="line"><span class="comment">#print(labels)</span></span><br><span class="line"><span class="comment">#print(trees.calcShannonEnt(myDat))</span></span><br></pre></td></tr></table></figure><h2 id="熵增大的原因"><a href="#熵增大的原因" class="headerlink" title="熵增大的原因"></a>熵增大的原因</h2><blockquote><p>熵越高，混合的数据就越多，如果我们在数据集中添加更多的分类，会导致熵结果增大</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#myDat[1][-1]='maybe'#更改list中某一元素的值（除yes和no外的值），即为添加更多的分类，中括号中为对应元素行列的位置</span></span><br><span class="line"><span class="comment">#print(myDat)</span></span><br><span class="line"><span class="comment">#print(trees.calcShannonEnt(myDat))  #分类变多，熵增大</span></span><br></pre></td></tr></table></figure><h2 id="append-和extend-两类方法的区别"><a href="#append-和extend-两类方法的区别" class="headerlink" title="append()和extend()两类方法的区别"></a>append()和extend()两类方法的区别</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b=[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">a.append(b)</span><br><span class="line"><span class="comment">#print(a)#[1, 2, 3, [4, 5, 6]]</span></span><br><span class="line">a.extend(b)</span><br><span class="line"><span class="comment">#print(a)#[1, 2, 3, [4, 5, 6], 4, 5, 6]</span></span><br></pre></td></tr></table></figure><h2 id="按照给定特征划分数据集"><a href="#按照给定特征划分数据集" class="headerlink" title="按照给定特征划分数据集"></a>按照给定特征划分数据集</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#print(myDat)</span></span><br><span class="line"><span class="comment">#print(trees.splitDataSet(myDat,0,1))</span></span><br><span class="line"><span class="comment">#print(trees.splitDataSet(myDat,0,0))</span></span><br></pre></td></tr></table></figure><h2 id="选择最好的数据集划分方式"><a href="#选择最好的数据集划分方式" class="headerlink" title="选择最好的数据集划分方式"></a>选择最好的数据集划分方式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#print(myDat)</span></span><br><span class="line"><span class="comment">#print(trees.chooseBestFeatureToSplit(myDat))</span></span><br></pre></td></tr></table></figure><h2 id="创建树-参数为数据集和标签列表"><a href="#创建树-参数为数据集和标签列表" class="headerlink" title="创建树,参数为数据集和标签列表"></a>创建树,参数为数据集和标签列表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">myTree=trees.createTree(myDat,labels)</span><br><span class="line"><span class="comment">#print(myTree)</span></span><br><span class="line"></span><br><span class="line">myDat,labels=trees.createDataSet()</span><br><span class="line">myTree1=treePlotter.retrieveTree(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#print(myTree1)</span></span><br><span class="line"><span class="comment">#print(trees.classify(myTree1,labels,[1,0]))</span></span><br><span class="line"><span class="comment">#print(trees.classify(myTree,labels,[1,1]))</span></span><br></pre></td></tr></table></figure><h2 id="决策树的存储"><a href="#决策树的存储" class="headerlink" title="决策树的存储"></a>决策树的存储</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">trees.storeTree(myTree,<span class="string">'classifierStorage.txt'</span>)</span><br><span class="line"><span class="comment">#print(trees.grabTree('classifierStorage.txt'))</span></span><br></pre></td></tr></table></figure><h2 id="使用决策树预测隐形眼镜类型"><a href="#使用决策树预测隐形眼镜类型" class="headerlink" title="使用决策树预测隐形眼镜类型"></a>使用决策树预测隐形眼镜类型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fr=open(<span class="string">'lenses.txt'</span>)</span><br><span class="line">lenses = [inst.strip().split(<span class="string">'\t'</span>) <span class="keyword">for</span> inst <span class="keyword">in</span> fr.readlines()]  <span class="comment">#将文本数据的每一个数据行按照tab键分割，并依次存入lenses</span></span><br><span class="line">lensesLabels = [<span class="string">'age'</span>, <span class="string">'prescript'</span>, <span class="string">'astigmatic'</span>, <span class="string">'tearRate'</span>]   <span class="comment"># 创建并存入特征标签列表</span></span><br><span class="line">lensesTree = trees.createTree(lenses, lensesLabels)   <span class="comment"># 根据继续文件得到的数据集和特征标签列表创建决策树</span></span><br><span class="line">print(lensesTree)</span><br><span class="line">treePlotter.createPlot(lensesTree)</span><br></pre></td></tr></table></figure><h1 id="treePlotter-py"><a href="#treePlotter-py" class="headerlink" title="treePlotter.py"></a>treePlotter.py</h1><blockquote><p>python中使用Matplotlib注解绘制树形图</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><h2 id="定义文本框和箭头格式"><a href="#定义文本框和箭头格式" class="headerlink" title="定义文本框和箭头格式"></a>定义文本框和箭头格式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">decisionNode = dict(boxstyle=<span class="string">"sawtooth"</span>, fc=<span class="string">"0.8"</span>)  <span class="comment"># boxstyle为文本框的类型，sawtooth是锯齿形，fc是边框线粗细,pad指的是外边框锯齿形（圆形等）的大小</span></span><br><span class="line">leafNode = dict(boxstyle=<span class="string">"round4"</span>, fc=<span class="string">"0.8"</span>)    <span class="comment">#定义决策树的叶子结点的描述属性，round4表示圆形</span></span><br><span class="line">arrow_args = dict(arrowstyle=<span class="string">"&lt;-"</span>)  <span class="comment">#定义箭头属性</span></span><br></pre></td></tr></table></figure><h2 id="plotNode-nodeTxt-centerPt-parentPt-nodeType"><a href="#plotNode-nodeTxt-centerPt-parentPt-nodeType" class="headerlink" title="plotNode(nodeTxt, centerPt, parentPt, nodeType)"></a>plotNode(nodeTxt, centerPt, parentPt, nodeType)</h2><blockquote><p>绘制带箭头的注解<br>annotate是关于一个数据点的文本<br>nodeTxt为要显示的文本，centerPt为文本的中心点，箭头所在的点，parentPt为指向文本的点<br>annotate的作用是添加注释，nodetxt是注释的内容<br>nodetype指的是输入的节点（边框）的形状</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plotNode</span><span class="params">(nodeTxt, centerPt, parentPt, nodeType)</span>:</span></span><br><span class="line">    createPlot.ax1.annotate(nodeTxt, xy=parentPt,  xycoords=<span class="string">'axes fraction'</span>,</span><br><span class="line">            xytext=centerPt, textcoords=<span class="string">'axes fraction'</span>,</span><br><span class="line">            va=<span class="string">"center"</span>, ha=<span class="string">"center"</span>, bbox=nodeType, arrowprops=arrow_args )</span><br></pre></td></tr></table></figure><h2 id="def-createPlot"><a href="#def-createPlot" class="headerlink" title="def createPlot():"></a>def createPlot():</h2><blockquote><p>第一版构造树函数，后面会改进，所以这里要注释上</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#fig = plt.figure(1, facecolor='white')</span></span><br><span class="line"><span class="comment">#fig.clf()</span></span><br><span class="line"><span class="comment">#createPlot.ax1 = plt.subplot(111, frameon=False) #ticks for demo puropses</span></span><br><span class="line"><span class="comment">#plotNode('a decision node', (0.5, 0.1), (0.1, 0.5), decisionNode)</span></span><br><span class="line"><span class="comment">#plotNode('a leaf node', (0.8, 0.1), (0.3, 0.8), leafNode)</span></span><br><span class="line"><span class="comment">#plt.show()</span></span><br></pre></td></tr></table></figure><h2 id="getNumLeafs-myTree"><a href="#getNumLeafs-myTree" class="headerlink" title="getNumLeafs(myTree)"></a>getNumLeafs(myTree)</h2><blockquote><p>计算叶子节点的个数<br>构造注解树，需要知道叶节点的个数，以便可以正确确定x轴的长度；要知道树的层数，可以确定y轴的高度。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getNumLeafs</span><span class="params">(myTree)</span>:</span>    </span><br><span class="line">    numLeafs = <span class="number">0</span></span><br><span class="line">    firstStr = list(myTree.keys())[<span class="number">0</span>]  <span class="comment">#获得myTree的第一个键值，即第一个特征，分割的标签</span></span><br><span class="line">    <span class="comment">#print(firstStr)</span></span><br><span class="line">    secondDict = myTree[firstStr]   <span class="comment">#根据键值得到对应的值，即根据第一个特征分类的结果</span></span><br><span class="line">    <span class="comment">#print(secondDict)</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> secondDict.keys():   <span class="comment">#获取第二个小字典中的key</span></span><br><span class="line">        <span class="keyword">if</span> type(secondDict[key]).__name__==<span class="string">'dict'</span>:</span><br><span class="line">            <span class="comment">#判断是否小字典中是否还包含新的字典（即新的分支）</span></span><br><span class="line">            numLeafs += getNumLeafs(secondDict[key])    <span class="comment">#包含的话进行递归从而继续循环获得新的分支所包含的叶节点的数量</span></span><br><span class="line">        <span class="keyword">else</span>:   numLeafs +=<span class="number">1</span>    <span class="comment">#不包含的话就停止迭代并把现在的小字典加一表示这边有一个分支</span></span><br><span class="line">    <span class="keyword">return</span> numLeafs</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getTreeDepth</span><span class="params">(myTree)</span>:</span>   <span class="comment">#计算判断节点的个数</span></span><br><span class="line">    maxDepth = <span class="number">0</span></span><br><span class="line">    firstStr = list(myTree.keys())[<span class="number">0</span>]</span><br><span class="line">    secondDict = myTree[firstStr]</span><br><span class="line">   <span class="keyword">for</span> key <span class="keyword">in</span> secondDict.keys():</span><br><span class="line">       <span class="keyword">if</span> type(secondDict[key]).__name__==<span class="string">'dict'</span>:</span><br><span class="line">           thisDepth = <span class="number">1</span> + getTreeDepth(secondDict[key])</span><br><span class="line">       <span class="keyword">else</span>:   thisDepth = <span class="number">1</span></span><br><span class="line">       <span class="keyword">if</span> thisDepth &gt; maxDepth: maxDepth = thisDepth</span><br><span class="line">    <span class="keyword">return</span> maxDepth</span><br></pre></td></tr></table></figure><h2 id="retrieveTree-i"><a href="#retrieveTree-i" class="headerlink" title="retrieveTree(i)"></a>retrieveTree(i)</h2><blockquote><p>预先存储树信息</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">retrieveTree</span><span class="params">(i)</span>:</span></span><br><span class="line">    listOfTrees =[&#123;<span class="string">'no surfacing'</span>: &#123;<span class="number">0</span>: <span class="string">'no'</span>, <span class="number">1</span>: &#123;<span class="string">'flippers'</span>: &#123;<span class="number">0</span>: <span class="string">'no'</span>, <span class="number">1</span>: <span class="string">'yes'</span>&#125;&#125;&#125;&#125;,</span><br><span class="line">                &#123;<span class="string">'no surfacing'</span>: &#123;<span class="number">0</span>: <span class="string">'no'</span>, <span class="number">1</span>: &#123;<span class="string">'flippers'</span>: &#123;<span class="number">0</span>: &#123;<span class="string">'head'</span>: &#123;<span class="number">0</span>: <span class="string">'no'</span>, <span class="number">1</span>: <span class="string">'yes'</span>&#125;&#125;, <span class="number">1</span>: <span class="string">'no'</span>&#125;&#125;&#125;&#125;</span><br><span class="line">                 ]</span><br><span class="line">    <span class="keyword">return</span> listOfTrees[i]</span><br></pre></td></tr></table></figure><h2 id="plotMidText-cntrPt-parentPt-txtString"><a href="#plotMidText-cntrPt-parentPt-txtString" class="headerlink" title="plotMidText(cntrPt, parentPt, txtString)"></a>plotMidText(cntrPt, parentPt, txtString)</h2><blockquote><p>作用是计算tree的中间位置，cntrPt起始位置,parentPt终止位置,txtString文本标签信息</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plotMidText</span><span class="params">(cntrPt, parentPt, txtString)</span>:</span></span><br><span class="line">    xMid = (parentPt[<span class="number">0</span>]-cntrPt[<span class="number">0</span>])/<span class="number">2.0</span> + cntrPt[<span class="number">0</span>]  <span class="comment">#cntrPt起点坐标，子节点坐标，parentPt结束坐标，父节点坐标</span></span><br><span class="line">    yMid = (parentPt[<span class="number">1</span>]-cntrPt[<span class="number">1</span>])/<span class="number">2.0</span> + cntrPt[<span class="number">1</span>]  <span class="comment">#找到x和y的中间位置</span></span><br><span class="line">    createPlot.ax1.text(xMid, yMid, txtString, va=<span class="string">"center"</span>, ha=<span class="string">"center"</span>, rotation=<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plotTree</span><span class="params">(myTree, parentPt, nodeTxt)</span>:</span></span><br><span class="line">    numLeafs = getNumLeafs(myTree)</span><br><span class="line">    depth = getTreeDepth(myTree)</span><br><span class="line">    firstStr = list(myTree.keys())[<span class="number">0</span>]</span><br><span class="line">   cntrPt = (plotTree.xOff + (<span class="number">1.0</span> + float(numLeafs))/<span class="number">2.0</span>/plotTree.totalW, plotTree.yOff)   <span class="comment">#计算子节点的坐标</span></span><br><span class="line">    plotMidText(cntrPt, parentPt, nodeTxt)      <span class="comment">#绘制线上的文字</span></span><br><span class="line">    plotNode(firstStr, cntrPt, parentPt, decisionNode)      <span class="comment">#绘制节点</span></span><br><span class="line">    secondDict = myTree[firstStr]</span><br><span class="line">    plotTree.yOff = plotTree.yOff - <span class="number">1.0</span>/plotTree.totalD     <span class="comment">#每绘制一次图，将y的坐标减少1.0/plottree.totald，间接保证y坐标上深度的</span></span><br><span class="line">   <span class="keyword">for</span> key <span class="keyword">in</span> secondDict.keys():</span><br><span class="line">       <span class="keyword">if</span> type(secondDict[key]).__name__==<span class="string">'dict'</span>:</span><br><span class="line">           plotTree(secondDict[key],cntrPt,str(key))</span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           plotTree.xOff = plotTree.xOff + <span class="number">1.0</span>/plotTree.totalW</span><br><span class="line">           plotNode(secondDict[key], (plotTree.xOff, plotTree.yOff), cntrPt, leafNode)</span><br><span class="line">           plotMidText((plotTree.xOff, plotTree.yOff), cntrPt, str(key))</span><br><span class="line">    plotTree.yOff = plotTree.yOff + <span class="number">1.0</span>/plotTree.totalD</span><br></pre></td></tr></table></figure><h2 id="createPlot-inTree"><a href="#createPlot-inTree" class="headerlink" title="createPlot(inTree)"></a>createPlot(inTree)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createPlot</span><span class="params">(inTree)</span>:</span></span><br><span class="line">    fig = plt.figure(<span class="number">1</span>, facecolor=<span class="string">'white'</span>)  <span class="comment">#类似于Matlab的figure，定义一个画布，背景为白色</span></span><br><span class="line">    fig.clf()   <span class="comment"># 把画布清空</span></span><br><span class="line">    axprops = dict(xticks=[], yticks=[])    <span class="comment">#subplot定义了一个绘图</span></span><br><span class="line">    createPlot.ax1 = plt.subplot(<span class="number">111</span>, frameon=<span class="keyword">False</span>, **axprops)    <span class="comment">#no ticks</span></span><br><span class="line">    <span class="comment">#createPlot.ax1为全局变量，绘制图像的句柄，111表示figure中的图有1行1列，即1个，最后的1代表第一个图,frameon表示是否绘制坐标轴矩形</span></span><br><span class="line">    plotTree.totalW = float(getNumLeafs(inTree))</span><br><span class="line">    plotTree.totalD = float(getTreeDepth(inTree))</span><br><span class="line">    plotTree.xOff = <span class="number">-0.5</span>/plotTree.totalW; plotTree.yOff = <span class="number">1.0</span>;</span><br><span class="line">    plotTree(inTree, (<span class="number">0.5</span>,<span class="number">1.0</span>), <span class="string">''</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><h1 id="treePlotter-main-py"><a href="#treePlotter-main-py" class="headerlink" title="treePlotter_main.py"></a>treePlotter_main.py</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>  treePlotter</span><br><span class="line"><span class="comment">#treePlotter.createPlot()</span></span><br><span class="line"><span class="comment">#print(treePlotter.retrieveTree(1))</span></span><br><span class="line">myTree=treePlotter.retrieveTree(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#print(treePlotter.getNumLeafs(myTree))</span></span><br><span class="line"><span class="comment">#print(treePlotter.getTreeDepth(myTree))</span></span><br><span class="line">myTree[<span class="string">'no surfacing'</span>][<span class="number">3</span>]=<span class="string">'maybe'</span></span><br><span class="line">treePlotter.createPlot(myTree)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;决策树&quot;&gt;&lt;a href=&quot;#决策树&quot; class=&quot;headerlink&quot; title=&quot;决策树&quot;&gt;&lt;/a&gt;决策树&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;优点：计算复杂度不高，输出结果易于理解，对中间值的缺失不敏感，可以处理不相关特诊数据&lt;br&gt;缺点：可能会产生过度匹配问题&lt;br&gt;使用数据类型：数值型和标称型&lt;br&gt;专家系统中，经常使用决策树&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://moyingyao.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="《机器学习实战》" scheme="http://moyingyao.github.io/tags/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98%E3%80%8B/"/>
    
      <category term="ML" scheme="http://moyingyao.github.io/tags/ML/"/>
    
      <category term="决策树" scheme="http://moyingyao.github.io/tags/%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>机器学习实战--KNN</title>
    <link href="http://moyingyao.github.io/2018/05/23/20180523%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-KNN/"/>
    <id>http://moyingyao.github.io/2018/05/23/20180523机器学习实战-KNN/</id>
    <published>2018-05-23T12:24:18.000Z</published>
    <updated>2019-03-14T08:50:40.252Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这本书的好就不多说的，其实如果不是因为机器学习那门学位课的作业是这个，我想我会错过这本书0.0</p></blockquote><h1 id="knn"><a href="#knn" class="headerlink" title="knn"></a>knn</h1><blockquote><p>优       点：精度高，对异常值不敏感，无数据输入假定<br>缺       点：计算复杂度高，空间复杂度高，无法给出数据的内在含义<br>使用数据范围：数值型和标称型 </p></blockquote><a id="more"></a><p><img src="https://i.imgur.com/1diiQIB.png" alt=""></p><p>————————————————————————————-下面进入正题————————————————————————————-</p><h1 id="kNN-py"><a href="#kNN-py" class="headerlink" title="kNN.py"></a>kNN.py</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *  </span><br><span class="line"><span class="keyword">import</span> operator  </span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> listdir</span><br></pre></td></tr></table></figure><h2 id="createDataSet"><a href="#createDataSet" class="headerlink" title="createDataSet()"></a>createDataSet()</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createDataSet</span><span class="params">()</span>:</span>  </span><br><span class="line">    group = array([[<span class="number">1.0</span>,<span class="number">1.1</span>],[<span class="number">1.0</span>,<span class="number">1.0</span>],[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0.1</span>]])  </span><br><span class="line">    labels = [<span class="string">'A'</span>,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'B'</span>]  </span><br><span class="line">    <span class="keyword">return</span> group, labels</span><br></pre></td></tr></table></figure><h2 id="classify0"><a href="#classify0" class="headerlink" title="classify0()"></a>classify0()</h2><blockquote><p>inX用于分类的输入向量,是一个向量<br>dataSet输入的训练样本集，是一个矩阵<br>labels标签向量<br>k用于选择最近邻居的数目<br>labels数目与dataSet的行数相同 </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classify0</span><span class="params">(inX, dataSet, labels, k)</span>:</span></span><br><span class="line">    dataSetSize = dataSet.shape[<span class="number">0</span>]  <span class="comment">#返回的是dataSet的行数，行数就是样本的数量</span></span><br><span class="line">    diffMat = tile(inX, (dataSetSize,<span class="number">1</span>)) - dataSet  <span class="comment">#矩阵相减</span></span><br><span class="line">    <span class="comment">#inX是个向量，而dataset是个矩阵，两者之间要进行相减的运算，需要把这个向量也补成一个和dataset有相同行数列数的矩阵，</span></span><br><span class="line">    <span class="comment">#tile()的第二个参数，就是(datasetsize,1)，这个参数的意思就是把inX补成有datasetsize行数的矩阵。</span></span><br><span class="line">    <span class="comment">#假如inX是（1，2），datasetsize =3，那么经过tile()转换后产生了一个这样的矩阵（[1,2],[1,2],[1,2]）</span></span><br><span class="line">    sqDiffMat = diffMat**<span class="number">2</span>  <span class="comment">#平方</span></span><br><span class="line">    sqDistances = sqDiffMat.sum(axis=<span class="number">1</span>) <span class="comment">#按行求和</span></span><br><span class="line">    <span class="comment"># sqdiffMat是([1,2],[0,1],[3,4])，axis这个参数影响了对矩阵求和时候的顺序，axis=0是按照列求和，结果为([3.1.7])</span></span><br><span class="line">    <span class="comment"># axis=1是按照行进行求和，结果是([4,7])。</span></span><br><span class="line">    distances = sqDistances**<span class="number">0.5</span>    <span class="comment">#开方，得到欧氏距离</span></span><br><span class="line">    sortedDistIndicies = distances.argsort()     <span class="comment">#把向量中每个元素进行排序，结果是元素的索引形成的向量</span></span><br><span class="line">    <span class="comment">#例子distance([1,4,3])，经过distance.argsort()之后的结果是([0,2,1]</span></span><br><span class="line">    classCount=&#123;&#125;       <span class="comment">#存放最终的分类结果及相应的结果投票数</span></span><br><span class="line">    <span class="comment">#投票过程，就是统计前k个最近的样本所属类别包含的样本个数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">        <span class="comment"># index = sortedDistIndicies[i]是第i个最相近的元素索引，即样本下标</span></span><br><span class="line">        <span class="comment"># voteIlabel = labels[index]是样本index对应的分类结果('A' or 'B')</span></span><br><span class="line">        voteIlabel = labels[sortedDistIndicies[i]]</span><br><span class="line">        <span class="comment"># classCount.get(voteIlabel, 0)返回voteIlabel的值，如果不存在，则返回0</span></span><br><span class="line">        <span class="comment"># 然后将票数增1</span></span><br><span class="line">        classCount[voteIlabel] = classCount.get(voteIlabel,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    <span class="comment"># 把分类结果进行排序，然后返回得票数最多的分类结果</span></span><br><span class="line">    <span class="comment"># key=operator.itemgetter(1)的意思是按照字典里的第一个排序</span></span><br><span class="line">    <span class="comment">#例子a = [1, 2, 3]，b = operator.itemgetter(1)，b(a)返回为2</span></span><br><span class="line">    <span class="comment">#b = operator.itemgetter(1, 0)，b(a)，定义函数b，获取对象的第1个域和第0个的值，返回 (2, 1)</span></span><br><span class="line">    <span class="comment"># reverse=True是降序排序</span></span><br><span class="line">    sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(<span class="number">1</span>), reverse=<span class="keyword">True</span>)</span><br><span class="line">    <span class="keyword">return</span> sortedClassCount[<span class="number">0</span>][<span class="number">0</span>] <span class="comment">#返回类别最多的类别</span></span><br></pre></td></tr></table></figure><h2 id="file2matrix"><a href="#file2matrix" class="headerlink" title="file2matrix()"></a>file2matrix()</h2><blockquote><p>将文本记录转换为NumPy<br>将文本记录转换为NumPy的解析程序<br>输入为矩阵，输出为训练样本矩阵和类标签向量</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">file2matrix</span><span class="params">(filename)</span>:</span></span><br><span class="line">    fr = open(filename)     <span class="comment">#打开文档</span></span><br><span class="line">    numberOfLines = len(fr.readlines())        <span class="comment">#得到文件行数</span></span><br><span class="line">    <span class="comment">#fr.readlines()读取行数,存在数组中,导入后每行中用\t隔开,两行之间用\n换行得到文件行数</span></span><br><span class="line">    returnMat = zeros((numberOfLines,<span class="number">3</span>))        <span class="comment">#创建返回NumPy矩阵，numberoflines行，3列的初始化零的矩阵</span></span><br><span class="line">    classLabelVector = []<span class="comment">#定义一个空的数组</span></span><br><span class="line">    fr = open(filename)</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> fr.readlines():</span><br><span class="line">        line = line.strip() <span class="comment">#删除（）中的内容，这里表示删除空格</span></span><br><span class="line">        listFromLine = line.split(<span class="string">'\t'</span>)<span class="comment">#以\t分割</span></span><br><span class="line">        <span class="comment">#print(listFromLine)</span></span><br><span class="line">        returnMat[index,:] = listFromLine[<span class="number">0</span>:<span class="number">3</span>]<span class="comment">#把每行前三个元素存入returnMat矩阵中，每行中存储三个</span></span><br><span class="line">        classLabelVector.append(int(listFromLine[<span class="number">-1</span>]))<span class="comment">#存储第四列元素即标签，在数组中append添加，-1表示最后一列</span></span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> returnMat,classLabelVector</span><br></pre></td></tr></table></figure><h2 id="autoNorm"><a href="#autoNorm" class="headerlink" title="autoNorm()"></a>autoNorm()</h2><blockquote><p>归一化数值，避免某特征值过大，使得权重比例不均匀，对计算结果产生影响。<br>autoNorm可以自动将数字特征值转化为0到1区间</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">autoNorm</span><span class="params">(dataSet)</span>:</span></span><br><span class="line">    minVals = dataSet.min(<span class="number">0</span>)<span class="comment">#一维数组，值为各项特征（列）中的最小值。参数0使得函数从列中选取最小值</span></span><br><span class="line">    <span class="comment">#print(minVals)</span></span><br><span class="line">    maxVals = dataSet.max(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">#print(maxVals)</span></span><br><span class="line">    ranges = maxVals - minVals</span><br><span class="line">   normDataSet = zeros(shape(dataSet)) <span class="comment">#创建与样本集一样大小的零矩阵</span></span><br><span class="line">   <span class="comment">#print(normDataSet)</span></span><br><span class="line">   m = dataSet.shape[<span class="number">0</span>]<span class="comment">#dataSet的行数</span></span><br><span class="line">   normDataSet = dataSet - tile(minVals, (m,<span class="number">1</span>))<span class="comment">#矩阵中所有的值减去最小值</span></span><br><span class="line">   <span class="comment">#tile将原来的一个数组minVals，扩充成了m行1列的数组</span></span><br><span class="line">   normDataSet = normDataSet/tile(ranges, (m,<span class="number">1</span>))   <span class="comment">#矩阵中所有的值除以最大取值范围进行归一化</span></span><br><span class="line">   <span class="keyword">return</span> normDataSet, ranges, minVals</span><br></pre></td></tr></table></figure><h2 id="datingClassTest"><a href="#datingClassTest" class="headerlink" title="datingClassTest()"></a>datingClassTest()</h2><blockquote><p>测试算法，样本集中百分之九十的数据用来训练样本，百分之十的样本用来测试分类器kNN.classify0()。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">datingClassTest</span><span class="params">()</span>:</span></span><br><span class="line">    hoRatio = <span class="number">0.10</span>      <span class="comment">#百分之十的数据用于测试分类器，更改该变量的值可更改参加测试分类器的数据量</span></span><br><span class="line">    datingDataMat,datingLabels = file2matrix(<span class="string">'datingTestSet2.txt'</span>)       <span class="comment">#导入数据</span></span><br><span class="line">   normMat, ranges, minVals = autoNorm(datingDataMat)      <span class="comment">#归一化数值</span></span><br><span class="line">   m = normMat.shape[<span class="number">0</span>]    <span class="comment">#得到总行数</span></span><br><span class="line">   numTestVecs = int(m*hoRatio)    <span class="comment">#测试总数据数量，m*hoRatio是一个浮点型，需转化成整形</span></span><br><span class="line">   errorCount = <span class="number">0.0</span>    <span class="comment">#初试错误率为0</span></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(numTestVecs):</span><br><span class="line">       classifierResult = classify0(normMat[i,:],normMat[numTestVecs:m,:],datingLabels[numTestVecs:m],<span class="number">3</span>)</span><br><span class="line">       <span class="comment">#分类器（需要测试的向量，训练样本集(90%)，标签集合，K）</span></span><br><span class="line">       print(<span class="string">"the classifier came back with: %d, the real answer is: %d"</span> % (classifierResult, datingLabels[i]))</span><br><span class="line">       <span class="keyword">if</span> (classifierResult != datingLabels[i]): errorCount += <span class="number">1.0</span>     <span class="comment">#计数，错误的个数</span></span><br><span class="line">   print(<span class="string">"the total error rate is: %f"</span> % (errorCount/float(numTestVecs)))      <span class="comment">#错误率</span></span><br><span class="line">   print(errorCount)</span><br></pre></td></tr></table></figure><h2 id="classifyPerson"><a href="#classifyPerson" class="headerlink" title="classifyPerson()"></a>classifyPerson()</h2><blockquote><p>约会数据,对于未来的约会预测函数，输入飞行里程数，玩视频游戏的百分比和冰激凌公升数，可以得到一个是否对他感兴趣的预测</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classifyPerson</span><span class="params">()</span>:</span></span><br><span class="line">    resultList=[<span class="string">'not at all'</span>,<span class="string">'in samll doses'</span>,<span class="string">'in large doses'</span>] <span class="comment">#三种感兴趣程度</span></span><br><span class="line">    percentTats=float(input(<span class="string">"percentage of time spent playing video games?"</span>))</span><br><span class="line">    ffMiles=floats=float(input(<span class="string">"frequent flier miles earned per year?"</span>))</span><br><span class="line">    iceCream=float(input(<span class="string">"liters of ice cream consuned per year?"</span>))<span class="comment">#input键盘输入</span></span><br><span class="line">    datingDataMat,datingLabels=file2matrix(<span class="string">'datingTestSet2.txt'</span>) <span class="comment"># 导入数据</span></span><br><span class="line">    normMat,ranges,minvals=autoNorm(datingDataMat) <span class="comment"># 归一化，ranges是归一化的分母</span></span><br><span class="line">    inArr=array([ffMiles,percentTats,iceCream]) <span class="comment"># inArr是归一化之前的datingDataMat数组中的行</span></span><br><span class="line">    classifierResult=classify0((inArr-minvals)/ranges,normMat,datingLabels,<span class="number">3</span>)<span class="comment">#先归一化，然后调用分类函数</span></span><br><span class="line">    <span class="comment">#print(classifierResult)</span></span><br><span class="line">    print(<span class="string">"you will probably like this person:%s"</span>%resultList[classifierResult<span class="number">-1</span>])</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="comment">## img2vector()</span></span><br><span class="line">&gt; 图片转向量</span><br><span class="line">手写体：<span class="number">32</span>*<span class="number">32</span>的黑白图像</span><br><span class="line">图片转向量，将<span class="number">32</span>*<span class="number">32</span>的二进制图像矩阵转换为<span class="number">1</span>*<span class="number">1024</span>的向量</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img2vector</span><span class="params">(filename)</span>:</span></span><br><span class="line">    returnVect = zeros((<span class="number">1</span>,<span class="number">1024</span>))</span><br><span class="line">    fr = open(filename)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):<span class="comment">#循环读出文件的前32行</span></span><br><span class="line">        lineStr = fr.readline()</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">32</span>):<span class="comment">#将每行的前32个字符存储在NumPy数组中</span></span><br><span class="line">            returnVect[<span class="number">0</span>,<span class="number">32</span>*i+j] = int(lineStr[j])</span><br><span class="line">    <span class="keyword">return</span> returnVect<span class="comment">#返回数组</span></span><br></pre></td></tr></table></figure><h2 id="handwritingClassTest"><a href="#handwritingClassTest" class="headerlink" title="handwritingClassTest()"></a>handwritingClassTest()</h2><blockquote><p>手写体测试</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handwritingClassTest</span><span class="params">()</span>:</span></span><br><span class="line">    hwLabels = []</span><br><span class="line">    trainingFileList = listdir(<span class="string">'trainingDigits'</span>)           <span class="comment">#导入训练数据</span></span><br><span class="line">    <span class="comment">#print(trainingFileList)</span></span><br><span class="line">    m = len(trainingFileList)   <span class="comment">#训练数据的总数</span></span><br><span class="line">    <span class="comment">#print(m)</span></span><br><span class="line">    trainingMat = zeros((m,<span class="number">1024</span>))   <span class="comment">#m行1024列的零向量</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">       fileNameStr = trainingFileList[i]   <span class="comment">#文件名</span></span><br><span class="line">       fileStr = fileNameStr.split(<span class="string">'.'</span>)[<span class="number">0</span>]     <span class="comment">#取文件名.之前的名字</span></span><br><span class="line">       classNumStr = int(fileStr.split(<span class="string">'_'</span>)[<span class="number">0</span>])    <span class="comment">#取文件名_之前的名字</span></span><br><span class="line">       hwLabels.append(classNumStr)</span><br><span class="line">       trainingMat[i,:] = img2vector(<span class="string">'trainingDigits/%s'</span> % fileNameStr)    <span class="comment">#将对应数据集下的文件一个个的转为向量</span></span><br><span class="line">       <span class="comment">#print(trainingMat[i,:])</span></span><br><span class="line">   testFileList = listdir(<span class="string">'testDigits'</span>)        <span class="comment">#测试数据</span></span><br><span class="line">    errorCount = <span class="number">0.0</span></span><br><span class="line">    mTest = len(testFileList)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(mTest):</span><br><span class="line">       fileNameStr = testFileList[i]</span><br><span class="line">       fileStr = fileNameStr.split(<span class="string">'.'</span>)[<span class="number">0</span>]</span><br><span class="line">       classNumStr = int(fileStr.split(<span class="string">'_'</span>)[<span class="number">0</span>])</span><br><span class="line">        vectorUnderTest = img2vector(<span class="string">'testDigits/%s'</span> % fileNameStr)</span><br><span class="line">       classifierResult = classify0(vectorUnderTest, trainingMat, hwLabels, <span class="number">3</span>) <span class="comment">#利用训练的trainingMat测试</span></span><br><span class="line">       print(<span class="string">"the classifier came back with: %d, the real answer is: %d"</span> % (classifierResult, classNumStr))</span><br><span class="line">       <span class="keyword">if</span> (classifierResult != classNumStr): errorCount += <span class="number">1.0</span></span><br><span class="line">    print(<span class="string">"\nthe total number of errors is: %d"</span> % errorCount)</span><br><span class="line">    print(<span class="string">"\nthe total error rate is: %f"</span> % (errorCount/float(mTest)))</span><br></pre></td></tr></table></figure><h1 id="knn-main-py"><a href="#knn-main-py" class="headerlink" title="knn_main.py"></a>knn_main.py</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kNN  </span><br><span class="line"><span class="keyword">import</span> matplotlib  </span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt  </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line"><span class="keyword">from</span> imp <span class="keyword">import</span> reload  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">group,labels=kNN.createDataSet()  </span><br><span class="line"><span class="comment">#print(group)  </span></span><br><span class="line"><span class="comment">#print(labels)  </span></span><br><span class="line"><span class="comment">#print(kNN.classify0([0,0],group,labels,3))</span></span><br></pre></td></tr></table></figure><h2 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fig=plt.figure()                <span class="comment">#建立画板  </span></span><br><span class="line">ax=fig.add_subplot(<span class="number">111</span>)         <span class="comment">#添加一个子图，一行一列第一个子块，若括号内为349，则三行四列第9个子块  </span></span><br><span class="line">reload(kNN)  </span><br><span class="line">datingDataMat,datingLabels=kNN.file2matrix(<span class="string">'datingTestSet2.txt'</span>)  </span><br><span class="line"><span class="comment">#print(datingDataMat)  </span></span><br><span class="line"><span class="comment">#ax.scatter(datingDataMat[:,1],datingDataMat[:,2])        # scatter绘制散点图,使用第二列第三列数据  </span></span><br><span class="line"><span class="comment">#ax.scatter(datingDataMat[:,1],datingDataMat[:,2],15.0*np.array(datingLabels),15.0*np.array(datingLabels))  </span></span><br><span class="line">ax.scatter(datingDataMat[:,<span class="number">0</span>],datingDataMat[:,<span class="number">1</span>],<span class="number">15.0</span>*np.array(datingLabels),<span class="number">15.0</span>*np.array(datingLabels))  </span><br><span class="line"><span class="comment">#plt.show()</span></span><br></pre></td></tr></table></figure><h2 id="归一化数值"><a href="#归一化数值" class="headerlink" title="归一化数值"></a>归一化数值</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">normMat,ranges,minVals=kNN.autoNorm(datingDataMat)  </span><br><span class="line"><span class="comment">#print(normMat)  </span></span><br><span class="line"><span class="comment">#print(ranges)  </span></span><br><span class="line"><span class="comment">#print(minVals)</span></span><br></pre></td></tr></table></figure><h2 id="测试算法"><a href="#测试算法" class="headerlink" title="测试算法"></a>测试算法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#kNN.datingClassTest()</span></span><br></pre></td></tr></table></figure><h2 id="约会预测"><a href="#约会预测" class="headerlink" title="约会预测"></a>约会预测</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#对于未来的约会预测函数，输入飞行里程数，玩视频游戏的百分比和冰激凌公升数，可以得到一个是否对他感兴趣的预测，  </span></span><br><span class="line"><span class="comment">#输入10   10000   0.5  </span></span><br><span class="line"><span class="comment">#kNN.classifyPerson()</span></span><br></pre></td></tr></table></figure><h2 id="手写体"><a href="#手写体" class="headerlink" title="手写体"></a>手写体</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#trainingDigits包含大约2000个例子，每个数字约有200个样本  </span></span><br><span class="line"><span class="comment">#testDigits包含大约900个测试数据  </span></span><br><span class="line">testVector=kNN.img2vector(<span class="string">'trainingDigits/0_13.txt'</span>)  </span><br><span class="line"><span class="comment">#print(testVector[0,0:31])  </span></span><br><span class="line"><span class="comment">#print(testVector[0,32:63])  </span></span><br><span class="line"><span class="comment">#print(testVector[0,64:95])  </span></span><br><span class="line">kNN.handwritingClassTest()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这本书的好就不多说的，其实如果不是因为机器学习那门学位课的作业是这个，我想我会错过这本书0.0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;knn&quot;&gt;&lt;a href=&quot;#knn&quot; class=&quot;headerlink&quot; title=&quot;knn&quot;&gt;&lt;/a&gt;knn&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;优       点：精度高，对异常值不敏感，无数据输入假定&lt;br&gt;缺       点：计算复杂度高，空间复杂度高，无法给出数据的内在含义&lt;br&gt;使用数据范围：数值型和标称型 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://moyingyao.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="《机器学习实战》" scheme="http://moyingyao.github.io/tags/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98%E3%80%8B/"/>
    
      <category term="ML" scheme="http://moyingyao.github.io/tags/ML/"/>
    
      <category term="KNN" scheme="http://moyingyao.github.io/tags/KNN/"/>
    
  </entry>
  
  <entry>
    <title>伊始</title>
    <link href="http://moyingyao.github.io/2018/05/17/20180517%E4%BC%8A%E5%A7%8B/"/>
    <id>http://moyingyao.github.io/2018/05/17/20180517伊始/</id>
    <published>2018-05-17T14:27:24.000Z</published>
    <updated>2019-03-14T08:48:23.957Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Welcome to AmberWu’s Blog! 为什么会想弄这么一个博客呢，还不是因为有那么一个研究僧程序猿且男屌丝，哦不不不，大神，嗯，大神0.0。第一次接触建站域名，随便弄弄。还挺有意思的，本以为这个很难，离自己很远，动起手来，真的蛮简单的，毕竟，本学渣弄得下来，哈哈哈<br><a id="more"></a></p></blockquote><h2 id="简单随便说说建站方法"><a href="#简单随便说说建站方法" class="headerlink" title="简单随便说说建站方法"></a>简单随便说说建站方法</h2><h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><blockquote><p>就是以Hexo为主，剩下的自行百度吧，毕竟我要回寝室，没时间写了</p></blockquote><h3 id="Github-Pages"><a href="#Github-Pages" class="headerlink" title="Github Pages"></a>Github Pages</h3><blockquote><p>以github为载体实现的，也百度吧，啊啊啊，实验室就剩我自己了。</p></blockquote><h3 id="配置域名"><a href="#配置域名" class="headerlink" title="配置域名"></a>配置域名</h3><blockquote><p>在博客的根目录下source文件中(例如：C:\hexo\source)新建一个名为CNAME的文件，注意没有任何后缀，用于github进行读取。在文件中添加自己的域名并保存，例如</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">amberwu.top</span><br></pre></td></tr></table></figure><blockquote><p>然后，重新生成静态文件并部署。CNAME文件也会被上传到github仓库当中，此时在浏览器中输入自己的域名，回车之后，你会第一次遇见自己的小天地~</p></blockquote><h3 id="Hexo的一些基本命令"><a href="#Hexo的一些基本命令" class="headerlink" title="Hexo的一些基本命令"></a>Hexo的一些基本命令</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean <span class="comment">#用于清除配置文件</span></span><br><span class="line">hexo g <span class="comment">#完整命令为hexo generate,用于生成静态文件</span></span><br><span class="line">hexo s <span class="comment">#完整命令为hexo server,用于启动服务器，主要用来本地预览</span></span><br></pre></td></tr></table></figure><blockquote><p>在浏览器地址栏输入<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a>, 按下回车键，熟悉的界面又出现了。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo d <span class="comment">#完整命令为hexo deploy,用于将本地文件发布到github等git仓库上</span></span><br><span class="line">hexo n <span class="string">"my article"</span> <span class="comment">#完整命令为hexo new,用于新建一篇名为“my article”的文章</span></span><br></pre></td></tr></table></figure><blockquote><p>这样就会在博客目录下source_posts中生成相应的 my article.md文件( 例如 C:\blog\source_posts\my article.md )</p></blockquote><h3 id="Hexo修改及配置主题"><a href="#Hexo修改及配置主题" class="headerlink" title="Hexo修改及配置主题"></a>Hexo修改及配置主题</h3><blockquote><p>hexo初始化之后默认的主题是landscape , 然后你可以去这个地址 <a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a> 里面找到你想要的主题。在github中搜索你要的主题名称，里面都会有该主题的如何使用的介绍，按着来就好了，反正就是改改改！我选的是next,看起来挺不错，至少是我喜欢的类型。</p></blockquote><p><strong>更改主题需要修改配置文件</strong></p><blockquote><p>更改主题需要修改配置文件，就是根目录下的_config.yml文件，找到 theme 字段，并将其值更改为next即可</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure><p><strong>配置next主题</strong></p><blockquote><p>next主题共分三种，在站点根目录/themes/next/_congig.yml 文件中修改，找到scheme关键字即可选择。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line">scheme: Pisces</span><br></pre></td></tr></table></figure><blockquote><p>当然，你完全可以进行很多的自定义设置甚至修改源码，定制自己的主题。小女子能力有限，更多的设置请参考官方文档<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">http://theme-next.iissnan.com/getting-started.html</a> </p></blockquote><p><strong>添加背景图片</strong></p><blockquote><p>将背景图片命名为background.jpg并放入主题根目录/source/images文件夹中<br>打开博客根目录/themes/next/source/css/_custom/custom.styl文件<br>加入如下代码：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Custom styles.</span><br><span class="line">body &#123; </span><br><span class="line">background-image: url(/images/background.jpg);</span><br><span class="line">background-attachment: fixed;</span><br><span class="line">background-repeat: no-repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更多资料"><a href="#更多资料" class="headerlink" title="更多资料"></a>更多资料</h3>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Welcome to AmberWu’s Blog! 为什么会想弄这么一个博客呢，还不是因为有那么一个研究僧程序猿且男屌丝，哦不不不，大神，嗯，大神0.0。第一次接触建站域名，随便弄弄。还挺有意思的，本以为这个很难，离自己很远，动起手来，真的蛮简单的，毕竟，本学渣弄得下来，哈哈哈&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="hexo" scheme="http://moyingyao.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://moyingyao.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
